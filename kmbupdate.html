<!DOCTYPE html>
<html lang="zh-HK">
<head>
  <meta charset="UTF-8" />
  <title>route number updates</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <meta name="theme-color" content="#003d6b" />
  <style>
    :root {
      --brand: #003d6b;
      --ok: #2e7d32;
      --warn: #ff9800;
      --bad: #c62828;
      --bg: #ffffff;
      --muted: #6b7280;
      --card: #f5f7fa;
      --border: #e5e7eb;
      --line: #e5e7eb;
      --pill-red-bg: #ffe8e8;
      --pill-red-fg: #b31c1c;
      --pill-amber-bg: #fff3e0;
      --pill-amber-fg: #a15c00;
      --pill-green-bg: #e8f5e9;
      --pill-green-fg: #1b5e20;
      --text-strong: #0f172a;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Noto Sans CJK TC", "PingFang TC", "Heiti TC", Arial, sans-serif;
      background: var(--bg);
      color: #111827;
    }
    header {
      position: sticky; top: 0; z-index: 10;
      background: var(--brand); color: #fff; padding: 12px 16px;
      display: flex; align-items: center; justify-content: space-between; gap: 12px;
    }
    body.pidstv header { display: none; } /* TV: hide top bar */
    header .title { font-size: 16px; font-weight: 700; letter-spacing: .3px; }
    header .clock { font-variant-numeric: tabular-nums; font-weight: 700; }
    main { padding: 12px; max-width: 1000px; margin: 0 auto; }

    .card { background: var(--card); border: 1px solid var(--border); border-radius: 10px; padding: 12px; }
    .controls { display: grid; grid-template-columns: 1fr; gap: 10px; }
    .row { display: grid; grid-template-columns: 1fr; gap: 8px; }
    label { font-size: 12px; color: var(--muted); display: block; margin-bottom: 6px; }
    input[type="text"], select {
      width: 100%; padding: 10px 12px; border: 1px solid var(--border); border-radius: 8px; font-size: 16px; background: #fff;
    }
    .chip-group { display: flex; gap: 8px; flex-wrap: wrap; }
    .chip {
      padding: 8px 12px; border-radius: 999px; border: 1px solid var(--border);
      background: #fff; color: #111827; font-weight: 600; font-size: 14px; cursor: pointer; user-select: none;
    }
    .chip.active { background: var(--brand); color: #fff; border-color: var(--brand); }
    .actions { display: flex; gap: 8px; flex-wrap: wrap; }
    button {
      appearance: none; border: none; background: var(--brand); color: #fff;
      padding: 10px 14px; font-size: 16px; border-radius: 10px; font-weight: 700; cursor: pointer;
    }
    button.secondary { background: #2563eb; }
    button.ghost { background: transparent; color: var(--brand); border: 1px solid var(--brand); }

    .status { margin-top: 12px; display: grid; gap: 8px; }
    .badge {
      display: inline-flex; align-items: center; gap: 8px; padding: 10px 12px; border-radius: 999px;
      font-weight: 700; font-size: 14px; border: 1px solid var(--border); background: #fff; width: 100%;
      justify-content: center; text-align: center;
    }
    .badge.ok { color: var(--ok); border-color: rgba(46,125,50,.25); background: #e8f5e9; }
    .badge.warn { color: var(--warn); border-color: rgba(255,152,0,.25); background: #fff3e0; }
    .badge.bad { color: var(--bad); border-color: rgba(198,40,40,.25); background: #ffebee; }
    .meta { font-size: 12px; color: var(--muted); display: flex; gap: 12px; flex-wrap: wrap; justify-content: center; }

    /* Summary blocks */
    .summary {
      display: block;
      margin: 12px 0;
      padding: 12px;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: #fff;
    }
    body.pidstv .summary.mobile-only { display: none; } /* mobile summary hidden in TV */
    .summary .title {
      display: inline-flex; align-items: center; gap: 8px;
      padding: 8px 14px; border-radius: 999px; font-weight: 800;
    }
    .summary .title.bad  { background: var(--pill-red-bg);   color: var(--pill-red-fg); }
    .summary .title.warn { background: var(--pill-amber-bg); color: var(--pill-amber-fg); }
    .summary .title.ok   { background: var(--pill-green-bg); color: var(--pill-green-fg); }
    .summary .lines { margin-top: 10px; }
    .summary .line { font-size: 14px; color: #111; padding: 4px 0; border-top: 1px dashed var(--line); }
    .summary .line:first-child { border-top: none; }
    .summary .section-label { font-weight: 800; color: #334155; margin-top: 8px; }

    .list { margin-top: 12px; border: 1px solid var(--border); border-radius: 10px; overflow: hidden; background: #fff; }
    .section { border-bottom: 1px solid var(--border); }
    .section-header { display: flex; justify-content: space-between; align-items: center; padding: 12px; background: #f9fafb; font-weight: 700; }
    .rows { padding: 8px 12px; }

    /* Stop row and ETA list styles */
    .rowitem { padding: 10px 0; border-top: 1px solid var(--line); }
    .rowitem:first-child { border-top: none; }
    .stop-head { display: flex; gap: 10px; align-items: baseline; margin-bottom: 6px; }
    .seq { min-width: 40px; font-weight: 700; color: var(--muted); text-align: right; padding-right: 4px; }
    .title2 { font-weight: 700; line-height: 1.2; }
    .eta-ul { list-style: none; margin: 0; padding: 0; }
    .eta-li { display: flex; align-items: center; justify-content: space-between; padding: 8px 0; border-top: 1px dashed var(--line); }
    .eta-li:first-child { border-top: none; }
    .eta-left { display: flex; align-items: baseline; gap: 6px; flex-wrap: wrap; }
    .eta-min { font-family: Arial, sans-serif; font-weight: 800; font-size: 22px; color: var(--text-strong); }
    .eta-min-text { font-weight: 700; color: var(--text-strong); }
    .eta-time { font-variant-numeric: tabular-nums; color: var(--muted); font-weight: 700; }
    .eta-rmk { display: inline-block; padding: 6px 10px; border-radius: 12px; font-size: 12px; margin-top: 6px; }
    .eta-rmk.bad { background: var(--pill-red-bg); color: var(--pill-red-fg); }
    .eta-rmk.warn { background: var(--pill-amber-bg); color: var(--pill-amber-fg); }

    .empty, .loading, .error, .na, .transient { text-align: center; color: var(--muted); padding: 12px; font-size: 14px; }
    .tips { margin-top: 12px; color: var(--muted); font-size: 12px; text-align: center; }
    footer.footer { margin: 16px 0; color: var(--muted); font-size: 12px; text-align: center; }

    /* TV mode: hide user controls completely */
    body.pidstv .card { display: none; }
    body.pidstv .tips { display: none; }

    /* Small floating bus button shown only in TV mode */
    .fab-bus {
      position: fixed; top: 10px; right: 10px; z-index: 9999;
      display: none; align-items: center; justify-content: center;
      width: 40px; height: 40px; border-radius: 50%;
      background: rgba(0,0,0,0.15); color: #000; border: 1px solid rgba(0,0,0,0.2);
      font-size: 20px; line-height: 1; cursor: pointer; backdrop-filter: blur(4px);
    }
    .fab-bus:hover { background: rgba(0,0,0,0.25); }
    body.pidstv .fab-bus { display: inline-flex; }

    @media (min-width: 640px) {
      header .title { font-size: 18px; }
      .controls .row { grid-template-columns: 180px 1fr; align-items: center; }
    }
  </style>
</head>
<body>
  <header>
    <div class="title">KMB Bus Service Update</div>
    <div class="clock" id="clock">--:--:--</div>
  </header>

  <main>
    <!-- TV summary (pidstv) -->
    <div id="tvSummary" class="summary" aria-live="polite" style="display:none;">
      <div id="tvSummaryTitle" class="title ok">âœ… æœå‹™æ­£å¸¸</div>
      <div id="tvSummaryLines" class="lines"></div>
    </div>

    <!-- TV mode floating bus to switch back to mobile -->
    <button id="busSwitch" class="fab-bus" title="åˆ‡æ›åˆ°æ‰‹æ©Ÿæ¨¡å¼">ğŸšŒ</button>

    <div class="card">
      <div class="controls">
        <div class="row">
          <label for="routes">è·¯ç·šç·¨è™Ÿï¼ˆæ”¯æ´å¤šå€‹ï¼Œé€—è™Ÿæˆ–ç©ºç™½åˆ†éš”ï¼Œæœ€å¤š1000ï¼›æˆ–è¼¸å…¥ ALLï¼‰</label>
          <input id="routes" type="text" placeholder="ä¾‹å¦‚ï¼š276A, 269C 33 æˆ– ALL" inputmode="latin-name" autocapitalize="characters" />
        </div>

        <div class="row">
          <label>æ¨¡å¼</label>
          <div class="chip-group" id="modeChips">
            <div class="chip" data-value="mobile">Mobile</div>
            <div class="chip" data-value="pidstv">TV (PIDS)</div>
          </div>
        </div>

        <div class="row">
          <label>æ–¹å‘</label>
          <div class="chip-group" id="dirChips">
            <div class="chip" data-value="outbound">å¾€ç›®çš„åœ° (outbound)</div>
            <div class="chip" data-value="inbound">è¿”å›ç¨‹ (inbound)</div>
            <div class="chip" data-value="both">å…©æ–¹å‘ (both)</div>
          </div>
        </div>

        <div class="row">
          <label>æœå‹™é¡å‹</label>
          <div class="chip-group" id="svcChips">
            <div class="chip" data-value="1">1</div>
            <div class="chip" data-value="2">2</div>
            <div class="chip" data-value="A">A</div>
            <div class="chip" data-value="all">å…¨éƒ¨</div>
          </div>
        </div>

        <div class="row">
          <label>é¡¯ç¤ºé¸é …</label>
          <div class="chip-group" id="filterChips">
            <div class="chip active" data-value="hideok">éš±è— æ­£å¸¸/ä¸é©ç”¨</div>
            <div class="chip active" data-value="affsum">é¡¯ç¤ºå—å½±éŸ¿æ‘˜è¦ï¼ˆé ‚éƒ¨ï¼‰</div>
          </div>
        </div>

        <!-- Advanced route scan -->
        <div class="row">
          <label>è·¯ç·šæƒæï¼ˆå¯é¸ï¼Œæ”¯æ´ URLï¼‰</label>
          <div class="chip-group" id="scanChips">
            <div class="chip" data-value="enable">å•Ÿç”¨æƒæ</div>
          </div>
          <div class="row" style="margin-top:6px;">
            <label>ä¾†æº</label>
            <div class="chip-group" id="scanSourceChips">
              <div class="chip active" data-value="all">å…¨æ¸¯è·¯ç·š</div>
              <div class="chip" data-value="input">åƒ…é™è¼¸å…¥</div>
            </div>
          </div>
          <div class="row" style="margin-top:6px;">
            <label>å‰ç¶´ï¼ˆå¤šå€‹ä»¥é€—è™Ÿåˆ†éš”ï¼Œä¾‹å¦‚ï¼šA,E,B æˆ– 2,3ï¼‰</label>
            <input id="scanPrefixes" type="text" placeholder="ä¾‹å¦‚ï¼šA,E,B æˆ– 2,3" />
          </div>
          <div class="row">
            <label>å¾Œç¶´ï¼ˆå¤šå€‹ä»¥é€—è™Ÿåˆ†éš”ï¼Œä¾‹å¦‚ï¼šA,B æˆ– P,Xï¼‰</label>
            <input id="scanEnds" type="text" placeholder="ä¾‹å¦‚ï¼šA,B æˆ– P,X" />
          </div>
          <div class="row">
            <label>ç¯„åœï¼ˆå«é¦–å°¾ï¼›å­—æ¯æˆ–æ•¸å­—ï¼‰</label>
            <div style="display:flex; gap:8px;">
              <input id="scanFrom" style="flex:1" type="text" placeholder="èµ·ï¼ˆä¾‹å¦‚ï¼š1 æˆ– Aï¼‰" />
              <input id="scanTo" style="flex:1" type="text" placeholder="è¨–ï¼ˆä¾‹å¦‚ï¼š99 æˆ– E99ï¼‰" />
            </div>
          </div>
        </div>

        <!-- ETA preview (optional) -->
        <div class="row">
          <label>ETA é è¦½ï¼ˆå¯é¸ï¼Œæ”¯æ´ URLï¼‰</label>
          <div class="chip-group" id="etaToggleChips">
            <div class="chip" data-value="eta">é¡¯ç¤º ETA é è¦½</div>
          </div>
          <div class="row" style="margin-top:6px;">
            <label>è·¯ç·šï¼ç«™é»ï¼æ–¹å‘ï¼æœå‹™é¡å‹</label>
            <div style="display:grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap:8px;">
              <input id="etaRoute" type="text" placeholder="ä¾‹å¦‚ï¼š276A" />
              <input id="etaStop" type="text" placeholder="ç«™é» ID ä¾‹å¦‚ï¼šWC674" />
              <select id="etaBound">
                <option value="outbound">outbound</option>
                <option value="inbound">inbound</option>
              </select>
              <select id="etaSvc">
                <option value="1">æœå‹™ 1</option>
                <option value="2">æœå‹™ 2</option>
                <option value="A">æœå‹™ A</option>
              </select>
            </div>
          </div>
        </div>

        <div class="row">
          <div class="actions">
            <button id="checkBtn" aria-label="Check congestion">æŸ¥è©¢</button>
            <button id="refreshBtn" class="secondary" aria-label="Refresh">é‡æ–°æ•´ç†</button>
            <button id="shareBtn" class="ghost" aria-label="Share link">åˆ†äº«</button>
            <button id="allRoutesBtn" class="ghost" aria-label="Load all KMB routes (HK)">å…¨æ¸¯æ‰€æœ‰è·¯ç·šï¼ˆå…©æ–¹å‘ï¼‰</button>
          </div>
        </div>
      </div>

      <div class="status" id="statusArea" style="display:none;">
        <div id="statusBadge" class="badge">è¼‰å…¥ä¸­â€¦</div>
        <div class="meta" id="metaText"></div>
      </div>
    </div>

    <!-- Mobile affected summary (optional, default on) -->
    <div id="mobileSummary" class="summary mobile-only" aria-live="polite" style="display:none;">
      <div id="mobileSummaryTitle" class="title ok">âœ… æœå‹™æ­£å¸¸</div>
      <div id="mobileSummaryLines" class="lines"></div>
    </div>

    <!-- Optional ETA preview result -->
    <div id="etaPreview" class="summary" style="display:none;">
      <div class="title ok">ETA é è¦½</div>
      <div id="etaPreviewBody" class="lines"></div>
    </div>

    <div id="results" class="list" style="display:block;"></div>

    <div class="tips">
      è³‡æ–™ä¾†æºï¼šä¹å·´å³æ™‚åˆ°ç«™ï¼ˆæ”¿åºœè³‡æ–™ä¸€ç·šé€šï¼‰ Â· é—œéµå­—ï¼šå—é˜»ï¼è¡Œè»Šå—é˜»ï¼å»¶èª¤ï¼è¡Œè»Šç·©æ…¢ï¼ç·©æ…¢ï¼äº‹æ•…ï¼å–æ¶ˆ
    </div>

    <footer class="footer" id="footer-info">
      æœ€å¾Œæ›´æ–°ï¼š--:--:-- Â· ç‰ˆæœ¬ï¼š14
    </footer>
  </main>

  <script>
    // -------- Utilities --------
    const $ = (sel) => document.querySelector(sel);
    const pad2 = (n) => (n > 9 ? '' : '0') + n;
    const nowStr = () => { const d = new Date(); let h = d.getHours(), m = d.getMinutes(), s = d.getSeconds(); h = h % 12 || 12; return h + ':' + pad2(m) + ':' + pad2(s); };
    const sleep = (ms) => new Promise(r => setTimeout(r, ms));
    const jitter = (ms) => ms + Math.floor(Math.random() * ms * 0.2);
    const toMinAndTime = (iso) => {
      if (!iso) return { min: '--', time: '--:--' };
      const t = new Date(iso), n = new Date();
      const mins = Math.max(0, Math.floor((t - n) / 60000));
      const hh = (t.getHours() % 12) || 12, mm = pad2(t.getMinutes());
      return { min: isNaN(mins) ? '--' : mins, time: `${hh}:${mm}` };
    };
    const naturalCompare = (a, b) => a.localeCompare(b, 'zh-HK', { numeric: true, sensitivity: 'base' });

    // -------- Clock --------
    const clock = $('#clock'); clock.textContent = nowStr(); setInterval(() => (clock.textContent = nowStr()), 1000);

    // -------- Params helpers --------
    function getParam(name, fallback = '') { const url = new URL(window.location.href); return url.searchParams.get(name) ?? fallback; }
    function setParams(key, val) { const url = new URL(window.location.href); if (val === undefined || val === null || val === '') url.searchParams.delete(key); else url.searchParams.set(key, String(val)); history.replaceState(null, '', url.toString()); }
    function safeSetParamsAll(obj) {
      const url = new URL(window.location.href);
      Object.entries(obj).forEach(([k,v])=>{
        if (v === undefined || v === null || v === '') url.searchParams.delete(k);
        else url.searchParams.set(k, Array.isArray(v)? v.join(','): String(v));
      });
      history.replaceState(null, '', url.toString());
    }

    // -------- API & rules --------
    const API = 'https://data.etabus.gov.hk/v1/transport/kmb';

    const SEVERE_KEYWORDS = [
      'è¡Œè»Šå—é˜»', 'å—é˜»',
      'æ­¤ç­æ¬¡å› äº‹æ•…å–æ¶ˆ', 'æ­¤ç­æ¬¡å› ',
      'ç­æ¬¡å› äº‹æ•…å–æ¶ˆ', 'ç­æ¬¡å› äº‹æ•…',
      'å› äº‹æ•…å–æ¶ˆ', 'äº‹æ•…å–æ¶ˆ',
      'äº‹æ•…', 'å–æ¶ˆ'
    ];
    const WARN_KEYWORDS = [ 'å»¶èª¤', 'è¡Œè»Šç·©æ…¢', 'ç·©æ…¢' ];
    const ALL_JAM_KEYWORDS = [...new Set([...SEVERE_KEYWORDS, ...WARN_KEYWORDS])];

    const OK_TEXT = 'æœå‹™æ­£å¸¸';
    const WARN_TEXT = 'å¯èƒ½å»¶èª¤ï¼è¡Œè»Šç·©æ…¢';
    const BAD_TEXT = 'è¡Œè»Šå—é˜»';
    const OFFLINE_TEXT = 'ç„¡æ³•é€£ç·š / é›¢ç·š';
    const NA_TEXT = 'ä¸é©ç”¨ï¼ˆè©²æœå‹™é¡å‹æœªæä¾›ï¼‰';
    const TRANSIENT_TEXT = 'æš«æ™‚ä¸å¯ç”¨ï¼ˆç¨å¾Œé‡è©¦ï¼‰';

    async function fetchJSON(url, { retries = 3, baseDelay = 500 } = {}) {
      for (let i = 0; i <= retries; i++) {
        try { const res = await fetch(url, { cache: 'no-store' }); if (!res.ok) throw new Error('HTTP ' + res.status); return await res.json(); }
        catch (e) { if (i === retries) { const err = new Error((e && e.message) || 'NETWORK_ERROR'); err.code = 'NETWORK_ERROR'; throw err; } await sleep(jitter(baseDelay * Math.pow(2, i))); }
      }
    }

    async function pMap(arr, mapper, concurrency = 4, { onEach, onProgress } = {}) {
      const ret = new Array(arr.length); let idx = 0, done = 0;
      const workers = Array(Math.min(concurrency, arr.length)).fill(0).map(async () => {
        while (true) { const i = idx++; if (i >= arr.length) break;
          let out; try { out = await mapper(arr[i], i); } catch (e) { out = { transient: true, error: (e && e.message) || 'UNKNOWN_ERROR' }; }
          ret[i] = out; done++; onEach && onEach(out, i, done, arr.length); onProgress && onProgress(done, arr.length);
        }
      });
      await Promise.all(workers);
      return ret;
    }

    const stopNameCache = new Map();
    async function getStopName(stopId) {
      if (stopNameCache.has(stopId)) return stopNameCache.get(stopId);
      try { const data = await fetchJSON(`${API}/stop/${stopId}`); const name = data?.data?.name_tc || stopId; stopNameCache.set(stopId, name); return name; } catch { return stopId; }
    }

    function containsAny(text, arr) { if (!text) return false; return arr.some(k => text.includes(k)); }
    function containsJamKeyword(text) { return containsAny(text, ALL_JAM_KEYWORDS); }
    function severityOf(text) { if (!text) return 0; if (containsAny(text, SEVERE_KEYWORDS)) return 2; if (containsAny(text, WARN_KEYWORDS)) return 1; return 0; }

    async function getRouteMeta(route, bound, svc) { try { const j = await fetchJSON(`${API}/route/${route}/${bound}/${svc}`); return j?.data || null; } catch (e) { if ((e && e.message || '').includes('HTTP 404')) return { NA: true }; return null; } }
    async function getStopsForRoute(route, bound, svc) { try { const j = await fetchJSON(`${API}/route-stop/${route}/${bound}/${svc}`); return j?.data || []; } catch (e) { if ((e && e.message || '').includes('HTTP 404')) { const err = new Error('NA'); err.code = 'NA'; throw err; } const err = new Error((e && e.message) || 'TRANSIENT'); err.code = 'TRANSIENT'; throw err; } }
    async function getETAForStopRoute(stopId, route, svc) { const j = await fetchJSON(`${API}/eta/${stopId}/${route}/${svc}`); return j?.data || []; }

    // -------- Collect 3 ETAs per affected stop --------
    async function detectJamForCombo({ route, bound, svc }) {
      const startedAt = Date.now(); const dirChar = bound === 'inbound' ? 'I' : 'O';
      let stops = [];
      try { stops = await getStopsForRoute(route, bound, svc); }
      catch (e) { if (e && e.code === 'NA') return { route, bound, svc, meta: null, hits: [], maxSeverity: 0, tookMs: Date.now() - startedAt, na: true }; return { route, bound, svc, meta: null, hits: [], maxSeverity: 0, tookMs: Date.now() - startedAt, transient: true, error: 'route-stop-transient' }; }
      if (!Array.isArray(stops) || stops.length === 0) return { route, bound, svc, meta: null, hits: [], maxSeverity: 0, tookMs: Date.now() - startedAt, na: true };

      let etaErrors = 0;
      const perStop = await pMap(stops, async (stop) => {
        try {
          const all = await getETAForStopRoute(stop.stop, route, svc);
          const list = all.filter(x => x?.eta && x?.dir === dirChar).sort((a,b)=> new Date(a.eta) - new Date(b.eta));
          const top3 = list.slice(0, 3).map(x => ({ eta: x.eta, rmk_tc: x.rmk_tc || '' }));
          const hasHit = top3.some(x => x.rmk_tc && containsJamKeyword(x.rmk_tc));
          if (hasHit) { const sev = top3.reduce((m, e) => Math.max(m, severityOf(e.rmk_tc)), 0); return { stopId: stop.stop, seq: Number(stop.seq), etas: top3, sev }; }
          return null;
        } catch { etaErrors++; return null; }
      }, 4);

      const hits = perStop.filter(Boolean).sort((a, b) => { if (b.sev !== a.sev) return b.sev - a.sev; return a.seq - b.seq; });

      let maxSeverity = 0; for (const st of hits) for (const e of st.etas) maxSeverity = Math.max(maxSeverity, severityOf(e.rmk_tc));
      const meta = await getRouteMeta(route, bound, svc).catch(() => null);
      const etaTransient = etaErrors / stops.length >= 0.8;

      return { route, bound, svc, meta, hits, maxSeverity, tookMs: Date.now() - startedAt, transient: etaTransient || false };
    }

    // -------- Section ordering (â›” on top) --------
    function comboOrderValue(o) {
      if (o.na) return 5;
      if (o.transient) return 4;
      if ((o.maxSeverity || 0) >= 2) return 0; // severe
      if ((o.maxSeverity || 0) === 1) return 1; // warning
      if ((o.hits?.length || 0) > 0) return 2;
      return 3; // normal
    }
    function reorderSections(container) {
      const sections = Array.from(container.children);
      sections.sort((a, b) => {
        const av = Number(a.getAttribute('data-order') || 99);
        const bv = Number(b.getAttribute('data-order') || 99);
        if (av !== bv) return av - bv;
        const at = a.querySelector('.sh-left')?.textContent || '';
        const bt = b.querySelector('.sh-left')?.textContent || '';
        return at.localeCompare(bt, 'zh-HK', { numeric: true });
      });
      sections.forEach(s => container.appendChild(s));
    }

    // -------- UI state --------
    const resultsEl = $('#results');

    const tvSummary = $('#tvSummary');
    const tvSummaryTitle = $('#tvSummaryTitle');
    const tvSummaryLines = $('#tvSummaryLines');

    const mobileSummary = $('#mobileSummary');
    const mobileSummaryTitle = $('#mobileSummaryTitle');
    const mobileSummaryLines = $('#mobileSummaryLines');

    const etaPreview = $('#etaPreview');
    const etaPreviewBody = $('#etaPreviewBody');

    let hideOk = true;       // hide æ­£å¸¸/ä¸é©ç”¨ sections
    let showAffSummary = true; // mobile affected summary toggle
    let scanEnable = false;
    let scanSource = 'all';  // 'all' | 'input'
    let mode = 'mobile';     // 'mobile' | 'pidstv'
    let showEta = false;

    const comboStore = new Map(); // key -> { data:o, names: {stopId: name} }

    function keyOf(o) { return `${o.route}-${o.bound}-${o.svc}`; }
    function sanitizeId(s) { return s.replace(/[^a-zA-Z0-9_-]/g,'_'); }
    function subBadgeText(sev, flags) { if (flags?.na) return 'â„¹ï¸ ä¸é©ç”¨'; if (flags?.transient) return 'â³ æš«æ™‚ä¸å¯ç”¨'; return sev === 0 ? 'âœ… æ­£å¸¸' : sev >= 2 ? 'â›” å—é˜»' : 'âš ï¸ ç·©æ…¢/å»¶èª¤'; }
    function rmkClass(rmk) { const s = severityOf(rmk || ''); return s >= 2 ? 'bad' : s === 1 ? 'warn' : ''; }

    function applyHideRule(section, o) {
      const normal = !o.na && !o.transient && (o.maxSeverity || 0) === 0 && ((o.hits?.length || 0) === 0);
      const shouldHide = (hideOk || mode === 'pidstv') && (o.na || normal);
      section.style.display = shouldHide ? 'none' : '';
    }

    function upsertSection(o, runId) {
      const key = keyOf(o);
      const id = `section-${sanitizeId(key)}`;
      let section = document.getElementById(id);

      const dirLabel = o.bound === 'outbound' ? 'å¾€ç›®çš„åœ°' : 'è¿”å›ç¨‹';
      const dest = o.meta?.dest_tc ? ` â†’ ${o.meta.dest_tc}` : '';
      const subBadge = subBadgeText(o.maxSeverity || 0, { transient: !!o.transient, na: !!o.na });
      const orderVal = comboOrderValue(o);

      if (!section) {
        section = document.createElement('div');
        section.className = 'section';
        section.id = id;
        section.setAttribute('data-key', key);
        section.innerHTML = `
          <div class="section-header">
            <div class="sh-left">${o.route}${dest}ï½œ${dirLabel}ï½œæœå‹™é¡å‹ï¼š${o.svc}</div>
            <div class="sh-badge">${subBadge}</div>
          </div>
          <div class="rows" id="rows-${sanitizeId(key)}">
            <div class="loading">è¼‰å…¥ç«™é»è©³æƒ…â€¦</div>
          </div>
        `;
        resultsEl.appendChild(section);
      } else {
        const shLeft = section.querySelector('.section-header .sh-left');
        const shBadge = section.querySelector('.section-header .sh-badge');
        if (shLeft) shLeft.textContent = `${o.route}${dest}ï½œ${dirLabel}ï½œæœå‹™é¡å‹ï¼š${o.svc}`;
        if (shBadge) shBadge.textContent = subBadge;
      }

      section.setAttribute('data-run-id', String(runId));
      section.setAttribute('data-order', String(orderVal));

      // Reorder with â›” first
      reorderSections(resultsEl);

      const rowsId = `rows-${sanitizeId(key)}`;
      const rowsEl = document.getElementById(rowsId);
      if (!rowsEl) return;

      if (o.na) {
        rowsEl.innerHTML = `<div class="na">${NA_TEXT}</div>`;
        afterUpsertStoreAndUpdate(o, key, {});
        return;
      }
      if (o.transient) {
        rowsEl.innerHTML = `<div class="transient">${TRANSIENT_TEXT}</div>`;
        afterUpsertStoreAndUpdate(o, key, {});
        return;
      }

      if ((o.hits?.length || 0) === 0) {
        rowsEl.innerHTML = `<div class="empty">æœªåµæ¸¬åˆ°åŒ…å«é—œéµå­—çš„æç¤ºã€‚</div>`;
        afterUpsertStoreAndUpdate(o, key, {});
      } else {
        Promise.all(o.hits.map(h => getStopName(h.stopId))).then(names => {
          const nameMap = {}; names.forEach((nm, idx) => { nameMap[o.hits[idx].stopId] = nm; });
          rowsEl.innerHTML = o.hits.map((h, i) => {
            const name = names[i] || h.stopId;
            const etaLis = (h.etas || []).slice(0, 3).map(et => {
              const { min, time } = toMinAndTime(et.eta);
              const klass = rmkClass(et.rmk_tc);
              const rmkHtml = et.rmk_tc ? `<div class="eta-rmk ${klass}">${et.rmk_tc}</div>` : '';
              return `
                <li class="eta-li">
                  <div class="eta-left">
                    <span class="eta-min">${min}</span><span class="eta-min-text">åˆ†</span>
                    ${rmkHtml}
                  </div>
                  <div class="eta-time">${time}</div>
                </li>
              `;
            }).join('');
            return `
              <div class="rowitem">
                <div class="stop-head">
                  <div class="seq">${h.seq}.</div>
                  <div class="title2">${name}</div>
                </div>
                <ul class="eta-ul">${etaLis}</ul>
              </div>
            `;
          }).join('');
          afterUpsertStoreAndUpdate(o, key, nameMap);
        });
      }
    }

    function afterUpsertStoreAndUpdate(o, key, nameMap) {
      applyHideRule(document.getElementById(`section-${sanitizeId(key)}`), o);
      comboStore.set(key, { data: o, names: nameMap });
      updateTvSummary();
      updateMobileSummary();
    }

    // -------- Summaries --------
    function aggregateByRoute() {
      const routeAgg = new Map(); // route -> { worst: -1/0/1/2, hasApplicable: false, hasTransient:false, samples: {severe:[], warn:[]} }
      comboStore.forEach(entry => {
        const o = entry.data; if (!o) return;
        if (!o.na) {
          const agg = routeAgg.get(o.route) || { worst: -1, hasApplicable: false, hasTransient: false, severe: [], warn: [] };
          agg.hasApplicable = true;
          if (o.transient) agg.hasTransient = true;
          const sev = o.maxSeverity || 0;
          if (!o.transient) agg.worst = Math.max(agg.worst, sev);
          if (sev >= 2) {
            const severeStops = (o.hits || []).filter(st => (st.etas || []).some(e => severityOf(e.rmk_tc) >= 2));
            const names = severeStops.slice(0, 3).map(st => entry.names?.[st.stopId] || st.stopId);
            agg.severe.push({ o, names });
          } else if (sev === 1) {
            const warnStops = (o.hits || []).filter(st => (st.etas || []).some(e => severityOf(e.rmk_tc) === 1));
            const names = warnStops.slice(0, 3).map(st => entry.names?.[st.stopId] || st.stopId);
            agg.warn.push({ o, names });
          }
          routeAgg.set(o.route, agg);
        }
      });
      return routeAgg;
    }

    function updateTvSummary() {
      const isTv = (mode === 'pidstv');
      tvSummary.style.display = isTv ? 'block' : 'none';
      if (!isTv) return;

      const routeAgg = aggregateByRoute();
      const severeLines = [];
      const warnLines = [];
      const normalLines = [];

      routeAgg.forEach((agg, route) => {
        if (agg.worst >= 2) {
          // Build lines for each severe combo sample
          const arr = agg.severe.length ? agg.severe : [{ o: { route, bound:'', svc:'' }, names: [] }];
          arr.forEach(({o, names}) => {
            const dirLabel = o.bound ? (o.bound === 'outbound' ? 'å¾€ç›®çš„åœ°' : 'è¿”å›ç¨‹') : '';
            const svcLabel = o.svc ? `ï½œæœå‹™é¡å‹ï¼š${o.svc}` : '';
            const nameStr = names && names.length ? ` â€” ${names.join('ã€')}` : '';
            severeLines.push(`${route}${dirLabel?('ï½œ'+dirLabel):''}${svcLabel}${nameStr}`);
          });
        } else if (agg.worst === 1) {
          const arr = agg.warn.length ? agg.warn : [{ o: { route, bound:'', svc:'' }, names: [] }];
          arr.forEach(({o, names}) => {
            const dirLabel = o.bound ? (o.bound === 'outbound' ? 'å¾€ç›®çš„åœ°' : 'è¿”å›ç¨‹') : '';
            const svcLabel = o.svc ? `ï½œæœå‹™é¡å‹ï¼š${o.svc}` : '';
            const nameStr = names && names.length ? ` â€” ${names.join('ã€')}` : '';
            warnLines.push(`${route}${dirLabel?('ï½œ'+dirLabel):''}${svcLabel}${nameStr}`);
          });
        } else if (agg.hasApplicable && agg.worst === 0 && !agg.hasTransient) {
          normalLines.push(`${route} æœå‹™æ­£å¸¸`);
        }
      });

      // Title state
      if (severeLines.length > 0) {
        tvSummaryTitle.textContent = 'â›” è¡Œè»Šå—é˜»';
        tvSummaryTitle.className = 'title bad';
      } else if (warnLines.length > 0) {
        tvSummaryTitle.textContent = 'âš ï¸ å¯èƒ½å»¶èª¤ï¼è¡Œè»Šç·©æ…¢';
        tvSummaryTitle.className = 'title warn';
      } else {
        tvSummaryTitle.textContent = 'âœ… æœå‹™æ­£å¸¸';
        tvSummaryTitle.className = 'title ok';
      }

      // Lines: show severe, warn, and ALWAYS also normal
      const parts = [];
      if (severeLines.length) {
        parts.push(`<div class="section-label">â›” å—é˜»</div>`);
        parts.push(...severeLines.sort(naturalCompare).map(t => `<div class="line">${t}</div>`));
      }
      if (warnLines.length) {
        parts.push(`<div class="section-label">âš ï¸ ç·©æ…¢ï¼å»¶èª¤</div>`);
        parts.push(...warnLines.sort(naturalCompare).map(t => `<div class="line">${t}</div>`));
      }
      if (normalLines.length) {
        parts.push(`<div class="section-label">âœ… æ­£å¸¸</div>`);
        parts.push(...normalLines.sort(naturalCompare).map(t => `<div class="line">${t}</div>`));
      }
      if (!parts.length) {
        parts.push(`<div class="line">ç›®å‰æœªåµæ¸¬åˆ°ã€Œè¡Œè»Šå—é˜»ã€çš„è·¯ç·šã€‚</div>`);
      }
      tvSummaryLines.innerHTML = parts.join('');
    }

    function updateMobileSummary() {
      // Optional affected summary on mobile (severe + warn). Default on; controlled by showAffSummary
      if (mode === 'pidstv') { mobileSummary.style.display = 'none'; return; }
      if (!showAffSummary) { mobileSummary.style.display = 'none'; return; }
      const routeAgg = aggregateByRoute();
      const severe = []; const warn = [];
      routeAgg.forEach((agg, route) => {
        if (agg.worst >= 2) severe.push(route);
        else if (agg.worst === 1) warn.push(route);
      });
      if (severe.length > 0) {
        mobileSummaryTitle.textContent = 'â›” è¡Œè»Šå—é˜»';
        mobileSummaryTitle.className = 'title bad';
      } else if (warn.length > 0) {
        mobileSummaryTitle.textContent = 'âš ï¸ å¯èƒ½å»¶èª¤ï¼è¡Œè»Šç·©æ…¢';
        mobileSummaryTitle.className = 'title warn';
      } else {
        mobileSummaryTitle.textContent = 'âœ… æœå‹™æ­£å¸¸';
        mobileSummaryTitle.className = 'title ok';
      }
      const lines = [];
      if (severe.length) {
        lines.push(`<div class="section-label">â›” å—é˜»</div>`);
        lines.push(...severe.sort(naturalCompare).map(r => `<div class="line">${r}</div>`));
      }
      if (warn.length) {
        lines.push(`<div class="section-label">âš ï¸ ç·©æ…¢ï¼å»¶èª¤</div>`);
        lines.push(...warn.sort(naturalCompare).map(r => `<div class="line">${r}</div>`));
      }
      if (!lines.length) lines.push(`<div class="line">ç›®å‰æœªåµæ¸¬åˆ°ã€Œè¡Œè»Šå—é˜»ã€çš„è·¯ç·šã€‚</div>`);
      mobileSummaryLines.innerHTML = lines.join('');
      mobileSummary.style.display = 'block';
    }

    // -------- Progress + badge meta --------
    function updateProgressMeta({ total, completed, hitCombos, naCombos, transientCombos, overall, tookMs }) {
      const pct = total ? Math.round((completed / total) * 100) : 0;
      $('#metaText').innerHTML = `
        <span>çµ„åˆæ•¸ï¼š${total}</span>
        <span>å·²å®Œæˆï¼š${completed}/${total}ï¼ˆ${pct}%ï¼‰</span>
        <span>æœ‰ç•°å¸¸çµ„åˆï¼š${hitCombos}</span>
        <span>ä¸é©ç”¨çµ„åˆï¼š${naCombos}</span>
        <span>æš«æ™‚ä¸å¯ç”¨ï¼š${transientCombos}</span>
        <span>ä¸Šæ¬¡æ›´æ–°ï¼š${nowStr()}</span>
        ${typeof tookMs === 'number' ? `<span>è€—æ™‚ï¼š${tookMs}ms</span>` : ''}
      `;
      const badge = $('#statusBadge');
      const applicable = Math.max(0, total - naCombos);
      const mostlyTransient = applicable > 0 && transientCombos / applicable >= 0.8;
      if (!navigator.onLine || mostlyTransient) { badge.className = 'badge bad'; badge.textContent = `âŒ ${OFFLINE_TEXT}`; return; }
      if (hitCombos > 0) { if (overall >= 2) { badge.className = 'badge bad'; badge.textContent = `â›” ${BAD_TEXT}`; } else { badge.className = 'badge warn'; badge.textContent = `âš ï¸ ${WARN_TEXT}`; } return; }
      badge.className = 'badge ok'; badge.textContent = `âœ… ${OK_TEXT}`;
    }

    // -------- Multi detection with incremental rendering --------
    const resultsElRef = $('#results');
    let lastQueryKey = '';
    let autoTimer = null;
    let usingAllRoutes = false;
    let currentRunId = 0;

    function setFooterUpdated() { $('#footer-info').textContent = `æœ€å¾Œæ›´æ–°ï¼š${nowStr()} Â· ç‰ˆæœ¬ï¼š14`; }

    function setActive(el, active) { if (!el) return; el.classList.toggle('active', !!active); }
    function getDirSelection() {
      const active = [...$('#dirChips').querySelectorAll('.chip.active')].map(c => c.dataset.value);
      if (active.includes('both')) return 'both';
      if (active.includes('outbound') && active.includes('inbound')) return 'both';
      return active[0] || 'outbound';
    }
    function getSvcSelection() { let active = [...$('#svcChips').querySelectorAll('.chip.active')].map(c => c.dataset.value); if (active.includes('all')) return ['all']; if (active.length === 0) active = ['1']; return active; }
    function getModeSelection() { const a = $('#modeChips .chip.active')?.dataset?.value; return a || 'mobile'; }

    function setMode(m) {
      mode = m === 'pidstv' ? 'pidstv' : 'mobile';
      document.body.classList.toggle('pidstv', mode === 'pidstv');
      tvSummary.style.display = mode === 'pidstv' ? 'block' : 'none';
      if (mode === 'pidstv') {
        hideOk = true; setActive($('#filterChips .chip[data-value="hideok"]'), true);
        document.querySelectorAll('.section').forEach(sec => {
          const key = sec.getAttribute('data-key'); const entry = comboStore.get(key); if (entry) applyHideRule(sec, entry.data);
        });
        updateTvSummary();
      } else {
        updateMobileSummary();
      }
    }

    // -------- Route scan config --------
    function parseCsv(str) { return (str || '').split(',').map(s => s.trim().toUpperCase()).filter(Boolean); }
    function getScanConfig() {
      return {
        enable: scanEnable,
        source: scanSource, // 'all' or 'input'
        prefixes: parseCsv($('#scanPrefixes').value),
        ends: parseCsv($('#scanEnds').value),
        rangeFrom: ($('#scanFrom').value || '').toUpperCase(),
        rangeTo: ($('#scanTo').value || '').toUpperCase()
      };
    }
    function matchScan(code, cfg) {
      const c = (code || '').toUpperCase();
      // prefixes (starts with any)
      if (cfg.prefixes.length > 0) {
        if (!cfg.prefixes.some(p => c.startsWith(p))) return false;
      }
      // ends with any in ends
      if (cfg.ends.length > 0) {
        if (!cfg.ends.some(p => c.endsWith(p))) return false;
      }
      // range inclusive
      if (cfg.rangeFrom && cfg.rangeTo) {
        if (naturalCompare(c, cfg.rangeFrom) < 0) return false;
        if (naturalCompare(c, cfg.rangeTo) > 0) return false;
      }
      return true;
    }

    async function fetchAllRouteCodes(limit = 1000) {
      const j = await fetchJSON(`${API}/route`);
      const list = (j?.data || []).map(x => (x.route || '').toUpperCase()).filter(Boolean);
      const uniq = [...new Set(list)].sort(naturalCompare);
      return uniq.slice(0, limit);
    }

    // -------- Gather routes (with scan support) --------
    async function gatherRoutes() {
      const inputVal = $('#routes').value.trim().toUpperCase();
      const cfg = getScanConfig();

      let baseRoutes = [];
      if (cfg.enable && cfg.source === 'all') {
        baseRoutes = await fetchAllRouteCodes(1000);
      } else if (inputVal === 'ALL') {
        usingAllRoutes = true;
        baseRoutes = await fetchAllRouteCodes(1000);
      } else {
        usingAllRoutes = false;
        baseRoutes = inputVal ? inputVal.split(/[\s,]+/).map(x=>x.trim()).filter(Boolean) : [];
      }

      // Apply scan filter if enabled
      let finalRoutes = baseRoutes;
      if (cfg.enable) {
        finalRoutes = baseRoutes.filter(code => matchScan(code, cfg));
      }

      // Deduplicate + cap
      finalRoutes = [...new Set(finalRoutes)].slice(0, 1000);
      return finalRoutes;
    }

    // -------- ETA Preview (fixed with fallbacks) --------
    async function renderEtaPreview() {
      if (!showEta) { etaPreview.style.display = 'none'; return; }
      const route = ($('#etaRoute').value || '').trim().toUpperCase();
      const stop = ($('#etaStop').value || '').trim().toUpperCase();
      const svc = ($('#etaSvc').value || '1').trim();
      const bound = ($('#etaBound').value || 'outbound');

      if (!route || !stop) {
        etaPreview.style.display = 'block';
        etaPreviewBody.innerHTML = `<div class="line">è«‹è¼¸å…¥è·¯ç·šèˆ‡ç«™é» IDã€‚</div>`;
        return;
      }

      try {
        const dirChar = bound === 'inbound' ? 'I' : 'O';
        const data = await fetchJSON(`${API}/eta/${stop}/${route}/${svc}`);
        const all = Array.isArray(data?.data) ? data.data : [];

        // Primary: exact dir with ETA
        let list = all.filter(x => x?.eta && x?.dir === dirChar).sort((a,b)=> new Date(a.eta) - new Date(b.eta));
        let note = '';

        // Fallback 1: alternate dir (user may have chosen the other bound for this stop)
        if (list.length === 0) {
          const alt = dirChar === 'I' ? 'O' : 'I';
          const altList = all.filter(x => x?.eta && x?.dir === alt).sort((a,b)=> new Date(a.eta) - new Date(b.eta));
          if (altList.length) {
            list = altList;
            note = 'ï¼ˆæç¤ºï¼šæ­¤ç«™æ­¤è·¯ç·šçš„å¦ä¸€æ–¹å‘æœ‰ç­æ¬¡ï¼‰';
          }
        }

        // Fallback 2: any ETA regardless of dir (some feeds omit dir)
        if (list.length === 0) {
          const anyList = all.filter(x => x?.eta).sort((a,b)=> new Date(a.eta) - new Date(b.eta));
          if (anyList.length) {
            list = anyList;
            note = 'ï¼ˆæç¤ºï¼šè³‡æ–™æœªæ¨™ç¤ºæ–¹å‘ï¼Œå·²é¡¯ç¤ºæ‰€æœ‰æ–¹å‘ï¼‰';
          }
        }

        const stopName = await getStopName(stop);
        const head = `<div class="section-label">è·¯ç·šï¼š${route}ï½œç«™é»ï¼š${stopName}ï¼ˆ${stop}ï¼‰ï½œ${bound}ï½œæœå‹™é¡å‹ï¼š${svc}</div>`;

        if (list.length) {
          const rows = list.slice(0,3).map(e => {
            const { min, time } = toMinAndTime(e.eta);
            const klass = rmkClass(e.rmk_tc || '');
            const rmkHtml = e.rmk_tc ? `<span class="eta-rmk ${klass}" style="margin-left:8px;">${e.rmk_tc}</span>` : '';
            return `<div class="line"><b>${min} åˆ†</b>ï¼ˆ${time}ï¼‰${rmkHtml}</div>`;
          });
          const noteLine = note ? `<div class="line" style="color:#64748b;">${note}</div>` : '';
          etaPreviewBody.innerHTML = head + rows.join('') + noteLine;
          etaPreview.style.display = 'block';
          return;
        }

        // Fallback 3: show remark-only records (e.g., å–æ¶ˆ/äº‹æ•… without ETA)
        const remarkOnly = all.filter(x => (x?.rmk_tc || x?.rmk_en)).slice(0,3);
        if (remarkOnly.length) {
          const rows = remarkOnly.map(e => {
            const klass = rmkClass(e.rmk_tc || e.rmk_en || '');
            const rmk = e.rmk_tc || e.rmk_en || '';
            return `<div class="line"><b>-- åˆ†</b>ï¼ˆ--:--ï¼‰<span class="eta-rmk ${klass}" style="margin-left:8px;">${rmk}</span></div>`;
          });
          etaPreviewBody.innerHTML = head + rows.join('') + `<div class="line" style="color:#64748b;">ï¼ˆæç¤ºï¼šç„¡å³æ™‚ç­æ¬¡ï¼Œåƒ…æœ‰å…¬å‘Šï¼‰</div>`;
          etaPreview.style.display = 'block';
          return;
        }

        // No data at all
        etaPreview.style.display = 'block';
        etaPreviewBody.innerHTML = head + `<div class="line">æ²’æœ‰ ETA å¯é¡¯ç¤ºã€‚</div>`;
      } catch (e) {
        etaPreview.style.display = 'block';
        etaPreviewBody.innerHTML = `<div class="line" style="color:#b31c1c;">ETA å–å¾—å¤±æ•—ï¼š${(e && e.message) ? e.message : e}</div>`;
      }
    }

    // -------- Run detection --------
    function setBusy(busy, { auto = false } = {}) {
      $('#checkBtn').disabled = busy && !auto;
      $('#refreshBtn').disabled = busy && !auto;
      $('#routes').disabled = busy && !auto;
      $('#allRoutesBtn').disabled = busy && !auto;
      $('#statusArea').style.display = 'block';
      $('#statusBadge').textContent = busy ? (auto ? 'æ›´æ–°ä¸­â€¦' : 'åˆ†æä¸­â€¦') : $('#statusBadge').textContent;
    }

    async function detectJamMulti({ routes, dirSel, svcSel, runId }) {
      const bounds = dirSel === 'both' ? ['outbound','inbound'] : [dirSel];
      const svcs = svcSel.includes('all') ? ['1','2','A'] : svcSel;
      const tasks = [];
      for (const r of routes) for (const b of bounds) for (const s of svcs) tasks.push({ route: r, bound: b, svc: s });

      let completed = 0, hitCombos = 0, naCombos = 0, transientCombos = 0, overall = 0;
      updateProgressMeta({ total: tasks.length, completed, hitCombos, naCombos, transientCombos, overall });

      const startedAt = Date.now();
      await pMap(tasks, detectJamForCombo, 4, {
        onEach: (out) => {
          if (runId !== currentRunId) return;
          upsertSection(out, runId);
          completed++;
          if (out.na) naCombos++;
          else if (out.transient) transientCombos++;
          else if ((out.hits?.length || 0) > 0) hitCombos++;
          overall = Math.max(overall, out.maxSeverity || 0);
          updateProgressMeta({ total: tasks.length, completed, hitCombos, naCombos, transientCombos, overall });
        }
      });

      const tookMs = Date.now() - startedAt;
      // Remove stale sections
      [...resultsElRef.children].forEach(sec => { if (sec.getAttribute && sec.getAttribute('data-run-id') !== String(runId)) resultsElRef.removeChild(sec); });
      updateProgressMeta({ total: tasks.length, completed, hitCombos, naCombos, transientCombos, overall, tookMs });
      return { overall, tookMs };
    }

    async function runDetect(force = false, { auto = false } = {}) {
      const dirSel = getDirSelection();
      const svcSel = getSvcSelection();
      const routes = await gatherRoutes();
      if (routes.length === 0) { alert('è«‹è¼¸å…¥è‡³å°‘ä¸€å€‹è·¯ç·šç·¨è™Ÿï¼Œæˆ–å•Ÿç”¨æƒæè¨­å®šã€‚'); return; }

      const paramsToSet = {
        route: ($('#routes').value.trim().toUpperCase() === 'ALL' || usingAllRoutes) ? 'ALL' : routes.join(','),
        mode, bound: dirSel, serviceType: svcSel.join(','),
        hideok: hideOk ? '1' : '0',
        affsum: showAffSummary ? '1' : '0',
        scan: scanEnable ? '1' : '0',
        scanSrc: scanSource,
        scanPrefixes: $('#scanPrefixes').value.trim(),
        scanEnds: $('#scanEnds').value.trim(),
        scanFrom: $('#scanFrom').value.trim(),
        scanTo: $('#scanTo').value.trim(),
        eta: showEta ? '1' : '0',
        etaRoute: $('#etaRoute').value.trim(),
        etaStop: $('#etaStop').value.trim(),
        etaSvc: $('#etaSvc').value,
        etaBound: $('#etaBound').value
      };

      const key = JSON.stringify(paramsToSet);
      if (!force && key === lastQueryKey) { /* no-op */ } else { safeSetParamsAll(paramsToSet); }
      lastQueryKey = key;

      currentRunId++; const runId = currentRunId;
      setBusy(true, { auto });
      try {
        await detectJamMulti({ routes, dirSel, svcSel, runId });
        await renderEtaPreview();
        setFooterUpdated();
      } catch (e) {
        $('#statusArea').style.display = 'block';
        $('#statusBadge').className = 'badge bad';
        $('#statusBadge').textContent = `âŒ ${OFFLINE_TEXT}`;
        const msg = (e && e.message) ? e.message : String(e || 'æœªçŸ¥éŒ¯èª¤');
        $('#metaText').innerHTML = `<span style="color:#b31c1c;">éŒ¯èª¤ï¼š${msg}</span>`;
      } finally { setBusy(false, { auto }); }
    }

    function startAutoRefresh() { if (autoTimer) clearInterval(autoTimer); autoTimer = setInterval(() => runDetect(true, { auto: true }), 30000); }

    // -------- Events --------
    $('#checkBtn').addEventListener('click', () => { runDetect(); startAutoRefresh(); });
    $('#refreshBtn').addEventListener('click', () => runDetect(true));
    $('#shareBtn').addEventListener('click', async () => { // share current URL
      try {
        if (navigator.share) await navigator.share({ title: 'route number updates', url: window.location.href });
        else if (navigator.clipboard) { await navigator.clipboard.writeText(window.location.href); alert('å·²è¤‡è£½åˆ†äº«é€£çµåˆ°å‰ªè²¼ç°¿'); }
        else { prompt('è¤‡è£½ä»¥ä¸‹é€£çµï¼š', window.location.href); }
      } catch {}
    });
    $('#allRoutesBtn').addEventListener('click', async () => {
      if (!confirm('æ­¤æ“ä½œæœƒæŠ“å–å…¨æ¸¯æ‰€æœ‰ä¹å·´è·¯ç·šä¸¦ä»¥ã€Œå…©æ–¹å‘ã€åˆ†æï¼Œå¯èƒ½éå¸¸è€—æ™‚ä¸¦æ¶ˆè€—æµé‡ã€‚æ˜¯å¦ç¹¼çºŒï¼Ÿ')) return;
      $('#routes').value = 'ALL';
      [...$('#dirChips').children].forEach(c => c.classList.remove('active'));
      setActive($('#dirChips .chip[data-value="both"]'), true);
      await runDetect(true);
      startAutoRefresh();
    });

    // Chips: mode
    $('#modeChips').addEventListener('click', (e) => { const chip = e.target.closest('.chip'); if (!chip) return; [...$('#modeChips').children].forEach(c => c.classList.remove('active')); chip.classList.add('active'); setMode(chip.dataset.value); setParams('mode', mode); updateTvSummary(); updateMobileSummary(); });

    // Chips: direction
    $('#dirChips').addEventListener('click', (e) => {
      const chip = e.target.closest('.chip'); if (!chip) return;
      const val = chip.dataset.value;
      if (val === 'both') { [...$('#dirChips').children].forEach(c => setActive(c, c.dataset.value === 'both')); }
      else {
        const was = chip.classList.contains('active');
        if (was && $('#dirChips').querySelectorAll('.chip.active').length === 1) return;
        chip.classList.toggle('active', !was);
        $('#dirChips .chip[data-value="both"]').classList.remove('active');
        if (!$('#dirChips').querySelectorAll('.chip.active').length) $('#dirChips .chip[data-value="outbound"]').classList.add('active');
      }
    });

    // Chips: service
    $('#svcChips').addEventListener('click', (e) => { const chip = e.target.closest('.chip'); if (!chip) return; const val = chip.dataset.value;
      if (val === 'all') { [...$('#svcChips').children].forEach(c => setActive(c, c.dataset.value === 'all')); }
      else { const was = chip.classList.contains('active'); setActive(chip, !was); $('#svcChips .chip[data-value="all"]').classList.remove('active'); if (!$('#svcChips').querySelectorAll('.chip.active').length) setActive(chip, true); }
    });

    // Chips: display options
    $('#filterChips').addEventListener('click', (e) => {
      const chip = e.target.closest('.chip'); if (!chip) return;
      const val = chip.dataset.value;
      if (val === 'hideok') {
        hideOk = !chip.classList.contains('active'); setActive(chip, hideOk);
        document.querySelectorAll('.section').forEach(sec => { const key = sec.getAttribute('data-key'); const entry = comboStore.get(key); if (entry) applyHideRule(sec, entry.data); });
        setParams('hideok', hideOk ? '1' : '0');
      } else if (val === 'affsum') {
        showAffSummary = !chip.classList.contains('active'); setActive(chip, showAffSummary);
        setParams('affsum', showAffSummary ? '1' : '0'); updateMobileSummary();
      }
    });

    // Chips: scan
    $('#scanChips').addEventListener('click', (e) => { const chip = e.target.closest('.chip'); if (!chip) return; if (chip.dataset.value === 'enable') { scanEnable = !chip.classList.contains('active'); setActive(chip, scanEnable); setParams('scan', scanEnable ? '1' : '0'); } });
    $('#scanSourceChips').addEventListener('click', (e) => { const chip = e.target.closest('.chip'); if (!chip) return; [...$('#scanSourceChips').children].forEach(c=>c.classList.remove('active')); chip.classList.add('active'); scanSource = chip.dataset.value || 'all'; setParams('scanSrc', scanSource); });

    // ETA toggle
    $('#etaToggleChips').addEventListener('click', (e) => { const chip = e.target.closest('.chip'); if (!chip) return; if (chip.dataset.value === 'eta') { showEta = !chip.classList.contains('active'); setActive(chip, showEta); setParams('eta', showEta ? '1' : '0'); renderEtaPreview(); } });
    ['etaRoute','etaStop','etaSvc','etaBound'].forEach(id => { const el = document.getElementById(id); el.addEventListener('change', ()=>{ if (showEta) renderEtaPreview(); }); el.addEventListener('keyup', ()=>{ if (showEta) renderEtaPreview(); }); });

    // TV floating bus: switch to mobile
    $('#busSwitch').addEventListener('click', () => { setMode('mobile'); [...$('#modeChips').children].forEach(c => c.classList.remove('active')); $('#modeChips .chip[data-value="mobile"]').classList.add('active'); setParams('mode', 'mobile'); updateMobileSummary(); });

    // -------- Init from URL --------
    (function init() {
      // defaults
      setActive($('#dirChips .chip[data-value="outbound"]'), true);
      setActive($('#svcChips .chip[data-value="1"]'), true);
      setActive($('#modeChips .chip[data-value="mobile"]'), true);
      setActive($('#filterChips .chip[data-value="hideok"]'), true);
      setActive($('#filterChips .chip[data-value="affsum"]'), true);
      setActive($('#scanSourceChips .chip[data-value="all"]'), true);

      // read params
      const routeParam = (getParam('route') || '').trim();
      const modeParam = (getParam('mode') || 'mobile').toLowerCase();
      const boundParam = (getParam('bound') || 'outbound').toLowerCase();
      const svcParam = (getParam('serviceType') || '1');

      const hideokParam = getParam('hideok'); hideOk = hideokParam === null ? true : hideokParam === '1'; setActive($('#filterChips .chip[data-value="hideok"]'), hideOk);
      const affsumParam = getParam('affsum'); showAffSummary = affsumParam === null ? true : affsumParam === '1'; setActive($('#filterChips .chip[data-value="affsum"]'), showAffSummary);

      const scanParam = getParam('scan'); scanEnable = scanParam === '1'; setActive($('#scanChips .chip[data-value="enable"]'), scanEnable);
      const scanSrcParam = (getParam('scanSrc') || 'all'); scanSource = (scanSrcParam === 'input') ? 'input' : 'all';
      [...$('#scanSourceChips').children].forEach(c=>c.classList.remove('active')); setActive($('#scanSourceChips .chip[data-value="'+scanSource+'"]'), true);
      $('#scanPrefixes').value = getParam('scanPrefixes','');
      $('#scanEnds').value = getParam('scanEnds','');
      $('#scanFrom').value = getParam('scanFrom','');
      $('#scanTo').value = getParam('scanTo','');

      const etaParam = getParam('eta'); showEta = etaParam === '1'; setActive($('#etaToggleChips .chip[data-value="eta"]'), showEta);
      $('#etaRoute').value = getParam('etaRoute','');
      $('#etaStop').value = getParam('etaStop','');
      $('#etaSvc').value = getParam('etaSvc','1');
      $('#etaBound').value = getParam('etaBound','outbound');

      $('#routes').value = routeParam;

      // mode
      [...$('#modeChips').children].forEach(c => setActive(c, false));
      setActive($('#modeChips .chip[data-value="'+(modeParam==='pidstv'?'pidstv':'mobile')+'"]'), true);
      setMode(modeParam);

      // direction
      [...$('#dirChips').children].forEach(c => setActive(c, false));
      const dirToActivate = (boundParam === 'both') ? ['both'] : [boundParam];
      dirToActivate.forEach(v => setActive($('#dirChips .chip[data-value="'+v+'"]'), true));
      if (![...$('#dirChips').querySelectorAll('.chip.active')].length) setActive($('#dirChips .chip[data-value="outbound"]'), true);

      // service
      [...$('#svcChips').children].forEach(c => setActive(c, false));
      const svcVals = svcParam.split(',').map(s => s.trim()).filter(Boolean);
      if (svcVals.includes('all')) setActive($('#svcChips .chip[data-value="all"]'), true);
      else {
        svcVals.forEach(v => setActive($('#svcChips .chip[data-value="'+v+'"]'), true));
        if (![...$('#svcChips').querySelectorAll('.chip.active')].length) setActive($('#svcChips .chip[data-value="1"]'), true);
      }

      const initial = routeParam.toUpperCase();
      if (initial) {
        if (initial === 'ALL') $('#routes').value = 'ALL';
        runDetect(false);
        startAutoRefresh();
      }
    })();
  </script>
</body>
</html>
