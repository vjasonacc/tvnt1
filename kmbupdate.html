<!DOCTYPE html>
<html lang="zh-HK">
<head>
  <meta charset="UTF-8" />
  <title>KMB Bus Service Update</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <meta name="theme-color" content="#003d6b" />
  <style>
    :root {
      --brand: #003d6b;
      --ok: #2e7d32;
      --warn: #ff9800;
      --bad: #c62828;
      --bg: #ffffff;
      --muted: #6b7280;
      --card: #f5f7fa;
      --border: #e5e7eb;
      --line: #e5e7eb;
      --pill-red-bg: #ffe8e8;
      --pill-red-fg: #b31c1c;
      --pill-amber-bg: #fff3e0;
      --pill-amber-fg: #a15c00;
      --pill-green-bg: #e8f5e9;
      --pill-green-fg: #1b5e20;
      --text-strong: #0f172a;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Noto Sans CJK TC", "PingFang TC", "Heiti TC", Arial, sans-serif;
      background: var(--bg);
      color: #111827;
    }
    header {
      position: sticky; top: 0; z-index: 10;
      background: var(--brand); color: #fff; padding: 12px 16px;
      display: flex; align-items: center; justify-content: space-between; gap: 12px;
    }
    body.pidstv header { display: none; } /* TV mode hides top bar */
    header .title { font-size: 16px; font-weight: 700; letter-spacing: .3px; }
    header .clock { font-variant-numeric: tabular-nums; font-weight: 700; }
    main { padding: 12px; max-width: 1000px; margin: 0 auto; }

    .card { background: var(--card); border: 1px solid var(--border); border-radius: 10px; padding: 12px; }
    .controls { display: grid; grid-template-columns: 1fr; gap: 10px; }
    .row { display: grid; grid-template-columns: 1fr; gap: 8px; }
    label { font-size: 12px; color: var(--muted); display: block; margin-bottom: 6px; }
    input[type="text"] {
      width: 100%; padding: 10px 12px; border: 1px solid var(--border); border-radius: 8px; font-size: 16px; background: #fff;
    }
    .chip-group { display: flex; gap: 8px; flex-wrap: wrap; }
    .chip {
      padding: 8px 12px; border-radius: 999px; border: 1px solid var(--border);
      background: #fff; color: #111827; font-weight: 600; font-size: 14px; cursor: pointer; user-select: none;
    }
    .chip.active { background: var(--brand); color: #fff; border-color: var(--brand); }
    .actions { display: flex; gap: 8px; flex-wrap: wrap; }
    button {
      appearance: none; border: none; background: var(--brand); color: #fff;
      padding: 10px 14px; font-size: 16px; border-radius: 10px; font-weight: 700; cursor: pointer;
    }
    button.secondary { background: #2563eb; }
    button.ghost { background: transparent; color: var(--brand); border: 1px solid var(--brand); }

    .status { margin-top: 12px; display: grid; gap: 8px; }
    .badge {
      display: inline-flex; align-items: center; gap: 8px; padding: 10px 12px; border-radius: 999px;
      font-weight: 700; font-size: 14px; border: 1px solid var(--border); background: #fff; width: 100%;
      justify-content: center; text-align: center;
    }
    .badge.ok { color: var(--ok); border-color: rgba(46,125,50,.25); background: #e8f5e9; }
    .badge.warn { color: var(--warn); border-color: rgba(255,152,0,.25); background: #fff3e0; }
    .badge.bad { color: var(--bad); border-color: rgba(198,40,40,.25); background: #ffebee; }
    .meta { font-size: 12px; color: var(--muted); display: flex; gap: 12px; flex-wrap: wrap; justify-content: center; }

    /* Summary (TV) */
    .summary {
      display: none;
      margin: 12px 0;
      padding: 12px;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: #fff;
    }
    body.pidstv .summary { display: block; }
    .summary .title {
      display: inline-flex; align-items: center; gap: 8px;
      padding: 8px 14px; border-radius: 999px; font-weight: 800;
    }
    .summary .title.bad  { background: var(--pill-red-bg);   color: var(--pill-red-fg); }
    .summary .title.warn { background: var(--pill-amber-bg); color: var(--pill-amber-fg); }
    .summary .title.ok   { background: var(--pill-green-bg); color: var(--pill-green-fg); }
    .summary .lines { margin-top: 10px; }
    .summary .line { font-size: 14px; color: #111; padding: 4px 0; border-top: 1px dashed var(--line); }
    .summary .line:first-child { border-top: none; }

    .list { margin-top: 12px; border: 1px solid var(--border); border-radius: 10px; overflow: hidden; background: #fff; }
    .section { border-bottom: 1px solid var(--border); }
    .section-header { display: flex; justify-content: space-between; align-items: center; padding: 12px; background: #f9fafb; font-weight: 700; }
    .rows { padding: 8px 12px; }

    /* Stop row and ETA list styles */
    .rowitem { padding: 10px 0; border-top: 1px solid var(--line); }
    .rowitem:first-child { border-top: none; }
    .stop-head { display: flex; gap: 10px; align-items: baseline; margin-bottom: 6px; }
    .seq { min-width: 40px; font-weight: 700; color: var(--muted); text-align: right; padding-right: 4px; }
    .title2 { font-weight: 700; line-height: 1.2; }
    .eta-ul { list-style: none; margin: 0; padding: 0; }
    .eta-li { display: flex; align-items: center; justify-content: space-between; padding: 8px 0; border-top: 1px dashed var(--line); }
    .eta-li:first-child { border-top: none; }
    .eta-left { display: flex; align-items: baseline; gap: 6px; flex-wrap: wrap; }
    .eta-min { font-family: Arial, sans-serif; font-weight: 800; font-size: 22px; color: var(--text-strong); }
    .eta-min-text { font-weight: 700; color: var(--text-strong); }
    .eta-time { font-variant-numeric: tabular-nums; color: var(--muted); font-weight: 700; }
    .eta-rmk { display: inline-block; padding: 6px 10px; border-radius: 12px; font-size: 12px; margin-top: 6px; }
    .eta-rmk.bad { background: var(--pill-red-bg); color: var(--pill-red-fg); }
    .eta-rmk.warn { background: var(--pill-amber-bg); color: var(--pill-amber-fg); }

    .empty, .loading, .error, .na, .transient { text-align: center; color: var(--muted); padding: 12px; font-size: 14px; }
    .tips { margin-top: 12px; color: var(--muted); font-size: 12px; text-align: center; }
    footer.footer { margin: 16px 0; color: var(--muted); font-size: 12px; text-align: center; }

    /* TV mode: hide user controls completely */
    body.pidstv .card { display: none; }
    body.pidstv .tips { display: none; }

    /* Small floating bus button shown only in TV mode */
    .fab-bus {
      position: fixed; top: 10px; right: 10px; z-index: 9999;
      display: none; align-items: center; justify-content: center;
      width: 40px; height: 40px; border-radius: 50%;
      background: rgba(0,0,0,0.15); color: #000; border: 1px solid rgba(0,0,0,0.2);
      font-size: 20px; line-height: 1; cursor: pointer; backdrop-filter: blur(4px);
    }
    .fab-bus:hover { background: rgba(0,0,0,0.25); }
    body.pidstv .fab-bus { display: inline-flex; }

    @media (min-width: 640px) {
      header .title { font-size: 18px; }
      .controls .row { grid-template-columns: 180px 1fr; align-items: center; }
    }
  </style>
</head>
<body>
  <header>
    <div class="title">KMB Bus Service Update</div>
    <div class="clock" id="clock">--:--:--</div>
  </header>

  <main>
    <!-- TV summary (only visible in pidstv mode) -->
    <div id="summary" class="summary" aria-live="polite">
      <div id="summaryTitle" class="title ok">âœ… æœå‹™æ­£å¸¸</div>
      <div id="summaryLines" class="lines"></div>
    </div>

    <!-- TV mode floating bus to switch back to mobile -->
    <button id="busSwitch" class="fab-bus" title="åˆ‡æ›åˆ°æ‰‹æ©Ÿæ¨¡å¼">ğŸšŒ</button>

    <div class="card">
      <div class="controls">
        <div class="row">
          <label for="routes">è·¯ç·šç·¨è™Ÿï¼ˆæ”¯æ´å¤šå€‹ï¼Œé€—è™Ÿæˆ–ç©ºç™½åˆ†éš”ï¼Œæœ€å¤š1000ï¼›æˆ–è¼¸å…¥ ALLï¼‰</label>
          <input id="routes" type="text" placeholder="ä¾‹å¦‚ï¼š276A, 269C 33 æˆ– ALL" inputmode="latin-name" autocapitalize="characters" />
        </div>

        <div class="row">
          <label>æ¨¡å¼</label>
          <div class="chip-group" id="modeChips">
            <div class="chip" data-value="mobile">Mobile</div>
            <div class="chip" data-value="pidstv">TV (PIDS)</div>
          </div>
        </div>

        <div class="row">
          <label>æ–¹å‘</label>
          <div class="chip-group" id="dirChips">
            <div class="chip" data-value="outbound">å¾€ç›®çš„åœ° (outbound)</div>
            <div class="chip" data-value="inbound">è¿”å›ç¨‹ (inbound)</div>
            <div class="chip" data-value="both">å…©æ–¹å‘ (both)</div>
          </div>
        </div>

        <div class="row">
          <label>æœå‹™é¡å‹</label>
          <div class="chip-group" id="svcChips">
            <div class="chip" data-value="1">1</div>
            <div class="chip" data-value="2">2</div>
            <div class="chip" data-value="A">A</div>
            <div class="chip" data-value="all">å…¨éƒ¨</div>
          </div>
        </div>

        <div class="row">
          <label>é¡¯ç¤ºé¸é …</label>
          <div class="chip-group" id="filterChips">
            <div class="chip active" data-value="hideok">éš±è— æ­£å¸¸/ä¸é©ç”¨</div>
          </div>
        </div>

        <div class="row">
          <div class="actions">
            <button id="checkBtn" aria-label="Check congestion">æŸ¥è©¢</button>
            <button id="refreshBtn" class="secondary" aria-label="Refresh">é‡æ–°æ•´ç†</button>
            <button id="shareBtn" class="ghost" aria-label="Share link">åˆ†äº«</button>
            <button id="allRoutesBtn" class="ghost" aria-label="Load all KMB routes (HK)">å…¨æ¸¯æ‰€æœ‰è·¯ç·šï¼ˆå…©æ–¹å‘ï¼‰</button>
          </div>
        </div>
      </div>

      <div class="status" id="statusArea" style="display:none;">
        <div id="statusBadge" class="badge">è¼‰å…¥ä¸­â€¦</div>
        <div class="meta" id="metaText"></div>
      </div>
    </div>

    <div id="results" class="list" style="display:block;"></div>

    <div class="tips">
      è³‡æ–™ä¾†æºï¼šä¹å·´å³æ™‚åˆ°ç«™ï¼ˆæ”¿åºœè³‡æ–™ä¸€ç·šé€šï¼‰ Â· é—œéµå­—ï¼šå—é˜»ï¼è¡Œè»Šå—é˜»ï¼å»¶èª¤ï¼è¡Œè»Šç·©æ…¢ï¼ç·©æ…¢ï¼äº‹æ•…ï¼å–æ¶ˆ
    </div>

    <footer class="footer" id="footer-info">
      æœ€å¾Œæ›´æ–°ï¼š--:--:-- Â· ç‰ˆæœ¬ï¼š12
    </footer>
  </main>

  <script>
    // -------- Utilities --------
    const $ = (sel) => document.querySelector(sel);
    const pad2 = (n) => (n > 9 ? '' : '0') + n;
    const nowStr = () => {
      const d = new Date(); let h = d.getHours(), m = d.getMinutes(), s = d.getSeconds();
      h = h % 12 || 12; return h + ':' + pad2(m) + ':' + pad2(s);
    };
    const sleep = (ms) => new Promise(r => setTimeout(r, ms));
    const jitter = (ms) => ms + Math.floor(Math.random() * ms * 0.2);
    const toMinAndTime = (iso) => {
      if (!iso) return { min: '--', time: '--:--' };
      const t = new Date(iso), n = new Date();
      const mins = Math.max(0, Math.floor((t - n) / 60000));
      const hh = (t.getHours() % 12) || 12, mm = pad2(t.getMinutes());
      return { min: isNaN(mins) ? '--' : mins, time: `${hh}:${mm}` };
    };

    // -------- Clock --------
    const clock = $('#clock'); clock.textContent = nowStr();
    setInterval(() => (clock.textContent = nowStr()), 1000);

    // -------- Params --------
    function getParam(name, fallback = '') {
      const url = new URL(window.location.href);
      return url.searchParams.get(name) ?? fallback;
    }
    function setParams(key, val) {
      const url = new URL(window.location.href);
      if (val === undefined || val === null || val === '') url.searchParams.delete(key);
      else url.searchParams.set(key, String(val));
      history.replaceState(null, '', url.toString());
    }
    function safeSetParamsMulti(routes, mode, dirSel, svcSel, hideok) {
      const url = new URL(window.location.href);
      try {
        const routeParam = allMode() ? 'ALL' : routes.join(',');
        url.searchParams.set('route', routeParam);
        url.searchParams.set('mode', mode);
        url.searchParams.set('bound', dirSel);
        url.searchParams.set('serviceType', svcSel.join(','));
        url.searchParams.set('hideok', hideok ? '1' : '0');
        history.replaceState(null, '', url.toString());
      } catch {}
    }

    // -------- API & rules --------
    const API = 'https://data.etabus.gov.hk/v1/transport/kmb';

    const SEVERE_KEYWORDS = [
      'è¡Œè»Šå—é˜»', 'å—é˜»',
      'æ­¤ç­æ¬¡å› äº‹æ•…å–æ¶ˆ', 'æ­¤ç­æ¬¡å› ',
      'ç­æ¬¡å› äº‹æ•…å–æ¶ˆ', 'ç­æ¬¡å› äº‹æ•…',
      'å› äº‹æ•…å–æ¶ˆ', 'äº‹æ•…å–æ¶ˆ',
      'äº‹æ•…', 'å–æ¶ˆ'
    ];
    const WARN_KEYWORDS = [ 'å»¶èª¤', 'è¡Œè»Šç·©æ…¢', 'ç·©æ…¢' ];
    const ALL_JAM_KEYWORDS = [...new Set([...SEVERE_KEYWORDS, ...WARN_KEYWORDS])];

    const OK_TEXT = 'æœå‹™æ­£å¸¸';
    const WARN_TEXT = 'å¯èƒ½å»¶èª¤ï¼è¡Œè»Šç·©æ…¢';
    const BAD_TEXT = 'è¡Œè»Šå—é˜»';
    const OFFLINE_TEXT = 'ç„¡æ³•é€£ç·š / é›¢ç·š';
    const NA_TEXT = 'ä¸é©ç”¨ï¼ˆè©²æœå‹™é¡å‹æœªæä¾›ï¼‰';
    const TRANSIENT_TEXT = 'æš«æ™‚ä¸å¯ç”¨ï¼ˆç¨å¾Œé‡è©¦ï¼‰';

    async function fetchJSON(url, { retries = 3, baseDelay = 500 } = {}) {
      for (let i = 0; i <= retries; i++) {
        try {
          const res = await fetch(url, { cache: 'no-store' });
          if (!res.ok) throw new Error('HTTP ' + res.status);
          return await res.json();
        } catch (e) {
          if (i === retries) { const err = new Error((e && e.message) || 'NETWORK_ERROR'); err.code = 'NETWORK_ERROR'; throw err; }
          await sleep(jitter(baseDelay * Math.pow(2, i)));
        }
      }
    }

    async function pMap(arr, mapper, concurrency = 4, { onEach, onProgress } = {}) {
      const ret = new Array(arr.length);
      let idx = 0, done = 0;
      const workers = Array(Math.min(concurrency, arr.length)).fill(0).map(async () => {
        while (true) {
          const i = idx++; if (i >= arr.length) break;
          let out;
          try { out = await mapper(arr[i], i); }
          catch (e) { out = { transient: true, error: (e && e.message) || 'UNKNOWN_ERROR' }; }
          ret[i] = out; done++;
          if (onEach) onEach(out, i, done, arr.length);
          if (onProgress) onProgress(done, arr.length);
        }
      });
      await Promise.all(workers);
      return ret;
    }

    const stopNameCache = new Map();
    async function getStopName(stopId) {
      if (stopNameCache.has(stopId)) return stopNameCache.get(stopId);
      try { const data = await fetchJSON(`${API}/stop/${stopId}`); const name = data?.data?.name_tc || stopId; stopNameCache.set(stopId, name); return name; }
      catch { return stopId; }
    }

    function containsAny(text, arr) { if (!text) return false; return arr.some(k => text.includes(k)); }
    function containsJamKeyword(text) { return containsAny(text, ALL_JAM_KEYWORDS); }
    function severityOf(text) {
      if (!text) return 0;
      if (containsAny(text, SEVERE_KEYWORDS)) return 2;
      if (containsAny(text, WARN_KEYWORDS)) return 1;
      return 0;
    }

    async function getRouteMeta(route, bound, svc) {
      try { const j = await fetchJSON(`${API}/route/${route}/${bound}/${svc}`); return j?.data || null; }
      catch (e) { if ((e && e.message || '').includes('HTTP 404')) return { NA: true }; return null; }
    }
    async function getStopsForRoute(route, bound, svc) {
      try { const j = await fetchJSON(`${API}/route-stop/${route}/${bound}/${svc}`); return j?.data || []; }
      catch (e) {
        if ((e && e.message || '').includes('HTTP 404')) { const err = new Error('NA'); err.code = 'NA'; throw err; }
        const err = new Error((e && e.message) || 'TRANSIENT'); err.code = 'TRANSIENT'; throw err;
      }
    }
    async function getETAForStopRoute(stopId, route, svc) { const j = await fetchJSON(`${API}/eta/${stopId}/${route}/${svc}`); return j?.data || []; }

    // -------- Collect 3 ETAs per affected stop --------
    async function detectJamForCombo({ route, bound, svc }) {
      const startedAt = Date.now();
      const dirChar = bound === 'inbound' ? 'I' : 'O';

      let stops = [];
      try { stops = await getStopsForRoute(route, bound, svc); }
      catch (e) {
        if (e && e.code === 'NA') return { route, bound, svc, meta: null, hits: [], maxSeverity: 0, tookMs: Date.now() - startedAt, na: true };
        return { route, bound, svc, meta: null, hits: [], maxSeverity: 0, tookMs: Date.now() - startedAt, transient: true, error: 'route-stop-transient' };
      }

      if (!Array.isArray(stops) || stops.length === 0) {
        return { route, bound, svc, meta: null, hits: [], maxSeverity: 0, tookMs: Date.now() - startedAt, na: true };
      }

      let etaErrors = 0;
      const perStop = await pMap(stops, async (stop) => {
        try {
          const all = await getETAForStopRoute(stop.stop, route, svc);
          const list = all
            .filter(x => x?.eta && x?.dir === dirChar)
            .sort((a,b)=> new Date(a.eta) - new Date(b.eta));
          const top3 = list.slice(0, 3).map(x => ({ eta: x.eta, rmk_tc: x.rmk_tc || '' }));
          const hasHit = top3.some(x => x.rmk_tc && containsJamKeyword(x.rmk_tc));
          if (hasHit) {
            const sev = top3.reduce((m, e) => Math.max(m, severityOf(e.rmk_tc)), 0);
            return { stopId: stop.stop, seq: Number(stop.seq), etas: top3, sev };
          }
          return null;
        } catch {
          etaErrors++; return null;
        }
      }, 4);

      const hits = perStop
        .filter(Boolean)
        .sort((a, b) => { if (b.sev !== a.sev) return b.sev - a.sev; return a.seq - b.seq; });

      let maxSeverity = 0;
      for (const st of hits) for (const e of st.etas) maxSeverity = Math.max(maxSeverity, severityOf(e.rmk_tc));

      const meta = await getRouteMeta(route, bound, svc).catch(() => null);
      const etaTransient = etaErrors / stops.length >= 0.8;

      return { route, bound, svc, meta, hits, maxSeverity, tookMs: Date.now() - startedAt, transient: etaTransient || false };
    }

    // -------- Section ordering (â›” on top) --------
    function comboOrderValue(o) {
      if (o.na) return 5;
      if (o.transient) return 4;
      if ((o.maxSeverity || 0) >= 2) return 0; // severe
      if ((o.maxSeverity || 0) === 1) return 1; // warning
      if ((o.hits?.length || 0) > 0) return 2;
      return 3; // normal
    }
    function reorderSections(container) {
      const sections = Array.from(container.children);
      sections.sort((a, b) => {
        const av = Number(a.getAttribute('data-order') || 99);
        const bv = Number(b.getAttribute('data-order') || 99);
        if (av !== bv) return av - bv;
        const at = a.querySelector('.sh-left')?.textContent || '';
        const bt = b.querySelector('.sh-left')?.textContent || '';
        return at.localeCompare(bt, 'zh-HK', { numeric: true });
      });
      sections.forEach(s => container.appendChild(s));
    }

    // -------- UI state --------
    const resultsEl = $('#results');
    const summaryTitleEl = $('#summaryTitle');
    const summaryLinesEl = $('#summaryLines');

    let hideOk = true;     // hide æ­£å¸¸/ä¸é©ç”¨ routes
    let mode = 'mobile';   // 'mobile' | 'pidstv'

    const comboStore = new Map(); // key -> { data:o, names: {stopId: name} }

    function keyOf(o) { return `${o.route}-${o.bound}-${o.svc}`; }
    function sanitizeId(s) { return s.replace(/[^a-zA-Z0-9_-]/g,'_'); }
    function subBadgeText(sev, flags) {
      if (flags?.na) return 'â„¹ï¸ ä¸é©ç”¨';
      if (flags?.transient) return 'â³ æš«æ™‚ä¸å¯ç”¨';
      return sev === 0 ? 'âœ… æ­£å¸¸' : sev >= 2 ? 'â›” å—é˜»' : 'âš ï¸ ç·©æ…¢/å»¶èª¤';
    }
    function rmkClass(rmk) { const s = severityOf(rmk || ''); return s >= 2 ? 'bad' : s === 1 ? 'warn' : ''; }

    function applyHideRule(section, o) {
      const normal = !o.na && !o.transient && (o.maxSeverity || 0) === 0 && ((o.hits?.length || 0) === 0);
      const shouldHide = (hideOk || mode === 'pidstv') && (o.na || normal);
      section.style.display = shouldHide ? 'none' : '';
    }

    function upsertSection(o, runId) {
      const key = keyOf(o);
      const id = `section-${sanitizeId(key)}`;
      let section = document.getElementById(id);

      const dirLabel = o.bound === 'outbound' ? 'å¾€ç›®çš„åœ°' : 'è¿”å›ç¨‹';
      const dest = o.meta?.dest_tc ? ` â†’ ${o.meta.dest_tc}` : '';
      const subBadge = subBadgeText(o.maxSeverity || 0, { transient: !!o.transient, na: !!o.na });
      const orderVal = comboOrderValue(o);

      if (!section) {
        section = document.createElement('div');
        section.className = 'section';
        section.id = id;
        section.setAttribute('data-key', key);
        section.innerHTML = `
          <div class="section-header">
            <div class="sh-left">${o.route}${dest}ï½œ${dirLabel}ï½œæœå‹™é¡å‹ï¼š${o.svc}</div>
            <div class="sh-badge">${subBadge}</div>
          </div>
          <div class="rows" id="rows-${sanitizeId(key)}">
            <div class="loading">è¼‰å…¥ç«™é»è©³æƒ…â€¦</div>
          </div>
        `;
        resultsEl.appendChild(section);
      } else {
        const shLeft = section.querySelector('.section-header .sh-left');
        const shBadge = section.querySelector('.section-header .sh-badge');
        if (shLeft) shLeft.textContent = `${o.route}${dest}ï½œ${dirLabel}ï½œæœå‹™é¡å‹ï¼š${o.svc}`;
        if (shBadge) shBadge.textContent = subBadge;
      }

      section.setAttribute('data-run-id', String(runId));
      section.setAttribute('data-order', String(orderVal));

      // Reorder with â›” first
      reorderSections(resultsEl);

      const rowsId = `rows-${sanitizeId(key)}`;
      const rowsEl = document.getElementById(rowsId);
      if (!rowsEl) return;

      if (o.na) {
        rowsEl.innerHTML = `<div class="na">${NA_TEXT}</div>`;
        applyHideRule(section, o);
        comboStore.set(key, { data: o, names: {} });
        updateSummaryBar();
        return;
      }
      if (o.transient) {
        rowsEl.innerHTML = `<div class="transient">${TRANSIENT_TEXT}</div>`;
        applyHideRule(section, o);
        comboStore.set(key, { data: o, names: {} });
        updateSummaryBar();
        return;
      }

      if ((o.hits?.length || 0) === 0) {
        rowsEl.innerHTML = `<div class="empty">æœªåµæ¸¬åˆ°åŒ…å«é—œéµå­—çš„æç¤ºã€‚</div>`;
        applyHideRule(section, o);
        comboStore.set(key, { data: o, names: {} });
        updateSummaryBar();
      } else {
        // Resolve stop names and render list
        Promise.all(o.hits.map(h => getStopName(h.stopId))).then(names => {
          const nameMap = {};
          names.forEach((nm, idx) => { nameMap[o.hits[idx].stopId] = nm; });

          rowsEl.innerHTML = o.hits.map((h, i) => {
            const name = names[i] || h.stopId;
            const etaLis = (h.etas || []).slice(0, 3).map(et => {
              const { min, time } = toMinAndTime(et.eta);
              const klass = rmkClass(et.rmk_tc);
              const rmkHtml = et.rmk_tc ? `<div class="eta-rmk ${klass}">${et.rmk_tc}</div>` : '';
              return `
                <li class="eta-li">
                  <div class="eta-left">
                    <span class="eta-min">${min}</span><span class="eta-min-text">åˆ†</span>
                    ${rmkHtml}
                  </div>
                  <div class="eta-time">${time}</div>
                </li>
              `;
            }).join('');
            return `
              <div class="rowitem">
                <div class="stop-head">
                  <div class="seq">${h.seq}.</div>
                  <div class="title2">${name}</div>
                </div>
                <ul class="eta-ul">${etaLis}</ul>
              </div>
            `;
          }).join('');

          comboStore.set(key, { data: o, names: nameMap });
          applyHideRule(section, o);
          updateSummaryBar();
        });
      }
    }

    // -------- Summary bar (TV) --------
    function updateSummaryBar() {
      if (mode !== 'pidstv') return; // only in TV mode

      // Gather severe, warn, and route-level normals
      const severeCombos = [];
      const warnCombos = [];
      const routeAgg = new Map(); // route -> { worst: -1/0/1/2, hasApplicable: false, hasTransient:false }

      comboStore.forEach(entry => {
        const o = entry.data;
        if (!o) return;

        // Build route aggregation
        if (!o.na) {
          const agg = routeAgg.get(o.route) || { worst: -1, hasApplicable: false, hasTransient: false };
          agg.hasApplicable = true;
          if (o.transient) agg.hasTransient = true;
          const sev = o.maxSeverity || 0;
          if (!o.transient) agg.worst = Math.max(agg.worst, sev);
          routeAgg.set(o.route, agg);
        }

        // Build combo lists
        if (o.transient || o.na) return;
        if ((o.maxSeverity || 0) >= 2) {
          severeCombos.push({ o, entry });
        } else if ((o.maxSeverity || 0) === 1) {
          warnCombos.push({ o, entry });
        }
      });

      // Decide title and lines
      if (severeCombos.length > 0) {
        summaryTitleEl.textContent = 'â›” è¡Œè»Šå—é˜»';
        summaryTitleEl.classList.remove('ok', 'warn');
        summaryTitleEl.classList.add('bad');

        const lines = severeCombos.map(({ o, entry }) => {
          const dirLabel = o.bound === 'outbound' ? 'å¾€ç›®çš„åœ°' : 'è¿”å›ç¨‹';
          const severeStops = (o.hits || []).filter(st => (st.etas || []).some(e => severityOf(e.rmk_tc) >= 2));
          const names = severeStops.slice(0, 3).map(st => entry.names?.[st.stopId] || st.stopId);
          return `${o.route}ï½œ${dirLabel}ï½œæœå‹™é¡å‹ï¼š${o.svc} â€” ${names.join('ã€')}`;
        });
        summaryLinesEl.innerHTML = lines.map(t => `<div class="line">${t}</div>`).join('');

      } else if (warnCombos.length > 0) {
        // Show warning state if any warning (no severe)
        summaryTitleEl.textContent = 'âš ï¸ å¯èƒ½å»¶èª¤ï¼è¡Œè»Šç·©æ…¢';
        summaryTitleEl.classList.remove('ok', 'bad');
        summaryTitleEl.classList.add('warn');

        const lines = warnCombos.map(({ o, entry }) => {
          const dirLabel = o.bound === 'outbound' ? 'å¾€ç›®çš„åœ°' : 'è¿”å›ç¨‹';
          // use first few warning stops
          const warnStops = (o.hits || []).filter(st => (st.etas || []).some(e => severityOf(e.rmk_tc) === 1));
          const names = warnStops.slice(0, 3).map(st => entry.names?.[st.stopId] || st.stopId);
          return `${o.route}ï½œ${dirLabel}ï½œæœå‹™é¡å‹ï¼š${o.svc} â€” ${names.join('ã€')}`;
        });
        summaryLinesEl.innerHTML = lines.length
          ? lines.map(t => `<div class="line">${t}</div>`).join('')
          : `<div class="line">åµæ¸¬åˆ°å»¶èª¤ï¼ç·©æ…¢ï¼Œä½†æœªèƒ½å–å¾—ç«™é»è©³æƒ…ã€‚</div>`;

      } else {
        // No severe, no warn => ONLY now consider as "æ­£å¸¸"
        summaryTitleEl.textContent = 'âœ… æœå‹™æ­£å¸¸';
        summaryTitleEl.classList.remove('bad', 'warn');
        summaryTitleEl.classList.add('ok');

        // List "route number æœå‹™æ­£å¸¸" for truly normal routes
        const normalRoutes = [];
        routeAgg.forEach((agg, route) => {
          // Truly normal when has applicable combos, worst severity == 0, and not transient
          if (agg.hasApplicable && agg.worst === 0 && !agg.hasTransient) {
            normalRoutes.push(route);
          }
        });
        normalRoutes.sort((a,b)=>a.localeCompare(b,'zh-HK',{numeric:true}));
        if (normalRoutes.length === 0) {
          summaryLinesEl.innerHTML = `<div class="line">ç›®å‰æœªåµæ¸¬åˆ°ã€Œè¡Œè»Šå—é˜»ã€çš„è·¯ç·šã€‚</div>`;
        } else {
          summaryLinesEl.innerHTML = normalRoutes
            .map(r => `<div class="line">${r} æœå‹™æ­£å¸¸</div>`)
            .join('');
        }
      }
    }

    // -------- Progress + badge meta --------
    function updateProgressMeta({ total, completed, hitCombos, naCombos, transientCombos, overall, tookMs }) {
      const pct = total ? Math.round((completed / total) * 100) : 0;
      $('#metaText').innerHTML = `
        <span>çµ„åˆæ•¸ï¼š${total}</span>
        <span>å·²å®Œæˆï¼š${completed}/${total}ï¼ˆ${pct}%ï¼‰</span>
        <span>æœ‰ç•°å¸¸çµ„åˆï¼š${hitCombos}</span>
        <span>ä¸é©ç”¨çµ„åˆï¼š${naCombos}</span>
        <span>æš«æ™‚ä¸å¯ç”¨ï¼š${transientCombos}</span>
        <span>ä¸Šæ¬¡æ›´æ–°ï¼š${nowStr()}</span>
        ${typeof tookMs === 'number' ? `<span>è€—æ™‚ï¼š${tookMs}ms</span>` : ''}
      `;

      const badge = $('#statusBadge');
      const applicable = Math.max(0, total - naCombos);
      const mostlyTransient = applicable > 0 && transientCombos / applicable >= 0.8;

      if (!navigator.onLine || mostlyTransient) { badge.className = 'badge bad'; badge.textContent = `âŒ ${OFFLINE_TEXT}`; return; }
      if (hitCombos > 0) {
        if (overall >= 2) { badge.className = 'badge bad'; badge.textContent = `â›” ${BAD_TEXT}`; }
        else { badge.className = 'badge warn'; badge.textContent = `âš ï¸ ${WARN_TEXT}`; }
        return;
      }
      badge.className = 'badge ok';
      badge.textContent = `âœ… ${OK_TEXT}`;
    }

    // -------- Multi detection with incremental rendering --------
    const resultsElRef = $('#results');
    let lastQueryKey = '';
    let autoTimer = null;
    let usingAllRoutes = false;
    let currentRunId = 0;

    function setFooterUpdated() { $('#footer-info').textContent = `æœ€å¾Œæ›´æ–°ï¼š${nowStr()} Â· ç‰ˆæœ¬ï¼š12`; }

    function setActive(el, active) { if (!el) return; el.classList.toggle('active', !!active); }
    function getDirSelection() {
      const active = [...$('#dirChips').querySelectorAll('.chip.active')].map(c => c.dataset.value);
      if (active.includes('both')) return 'both';
      if (active.includes('outbound') && active.includes('inbound')) return 'both';
      return active[0] || 'outbound';
    }
    function getSvcSelection() {
      let active = [...$('#svcChips').querySelectorAll('.chip.active')].map(c => c.dataset.value);
      if (active.includes('all')) return ['all'];
      if (active.length === 0) active = ['1'];
      return active;
    }
    function setMode(m) {
      mode = m === 'pidstv' ? 'pidstv' : 'mobile';
      document.body.classList.toggle('pidstv', mode === 'pidstv');
      if (mode === 'pidstv') {
        hideOk = true;
        setActive($('#filterChips .chip[data-value="hideok"]'), true);
        document.querySelectorAll('.section').forEach(sec => {
          const key = sec.getAttribute('data-key');
          const entry = comboStore.get(key);
          if (entry) applyHideRule(sec, entry.data);
        });
        updateSummaryBar();
      }
    }
    function setFromParams() {
      // Defaults
      setActive($('#dirChips .chip[data-value="outbound"]'), true);
      setActive($('#svcChips .chip[data-value="1"]'), true);
      setActive($('#modeChips .chip[data-value="mobile"]'), true);
      setActive($('#filterChips .chip[data-value="hideok"]'), true);

      const routeParam = (getParam('route') || '').trim();
      const modeParam = (getParam('mode') || 'mobile').toLowerCase();
      const boundParam = (getParam('bound') || 'outbound').toLowerCase();
      const svcParam = (getParam('serviceType') || '1');
      const hideokParam = getParam('hideok');

      $('#routes').value = routeParam;

      // mode
      [...$('#modeChips').children].forEach(c => setActive(c, false));
      setActive($('#modeChips .chip[data-value="'+(modeParam==='pidstv'?'pidstv':'mobile')+'"]'), true);
      setMode(modeParam);

      // direction
      [...$('#dirChips').children].forEach(c => setActive(c, false));
      const dirToActivate = (boundParam === 'both') ? ['both'] : [boundParam];
      dirToActivate.forEach(v => setActive($('#dirChips .chip[data-value="'+v+'"]'), true));
      if (![...$('#dirChips').querySelectorAll('.chip.active')].length) setActive($('#dirChips .chip[data-value="outbound"]'), true);

      // service
      [...$('#svcChips').children].forEach(c => setActive(c, false));
      const svcVals = svcParam.split(',').map(s => s.trim()).filter(Boolean);
      if (svcVals.includes('all')) setActive($('#svcChips .chip[data-value="all"]'), true);
      else {
        svcVals.forEach(v => setActive($('#svcChips .chip[data-value="'+v+'"]'), true));
        if (![...$('#svcChips').querySelectorAll('.chip.active')].length) setActive($('#svcChips .chip[data-value="1"]'), true);
      }

      // hide ok/NA
      hideOk = hideokParam === null ? true : hideokParam === '1';
      setActive($('#filterChips .chip[data-value="hideok"]'), hideOk);
    }

    function normalizeRoutes(input) {
      const parts = input.split(/[\s,]+/).map(x => x.trim().toUpperCase()).filter(Boolean);
      const uniq = [...new Set(parts)].slice(0, 1000); return uniq;
    }

    async function gatherRoutes() {
      const value = $('#routes').value.trim().toUpperCase();
      if (value === 'ALL') {
        usingAllRoutes = true;
        const j = await fetchJSON(`${API}/route`);
        const list = (j?.data || []).map(x => (x.route || '').toUpperCase()).filter(Boolean);
        return [...new Set(list)].slice(0, 1000);
      }
      usingAllRoutes = false;
      return normalizeRoutes(value);
    }
    function allMode() { return $('#routes').value.trim().toUpperCase() === 'ALL'; }

    function setBusy(busy, { auto = false } = {}) {
      $('#checkBtn').disabled = busy && !auto;
      $('#refreshBtn').disabled = busy && !auto;
      $('#routes').disabled = busy && !auto;
      $('#allRoutesBtn').disabled = busy && !auto;
      $('#statusArea').style.display = 'block';
      $('#statusBadge').textContent = busy ? (auto ? 'æ›´æ–°ä¸­â€¦' : 'åˆ†æä¸­â€¦') : $('#statusBadge').textContent;
    }

    async function detectJamMulti({ routes, dirSel, svcSel, runId }) {
      const bounds = dirSel === 'both' ? ['outbound','inbound'] : [dirSel];
      const svcs = svcSel.includes('all') ? ['1','2','A'] : svcSel;
      const tasks = [];
      for (const r of routes) for (const b of bounds) for (const s of svcs) tasks.push({ route: r, bound: b, svc: s });

      let completed = 0, hitCombos = 0, naCombos = 0, transientCombos = 0, overall = 0;
      updateProgressMeta({ total: tasks.length, completed, hitCombos, naCombos, transientCombos, overall });

      const startedAt = Date.now();
      await pMap(
        tasks,
        detectJamForCombo,
        4,
        {
          onEach: (out) => {
            if (runId !== currentRunId) return;
            upsertSection(out, runId);
            completed++;
            if (out.na) naCombos++;
            else if (out.transient) transientCombos++;
            else if ((out.hits?.length || 0) > 0) hitCombos++;
            overall = Math.max(overall, out.maxSeverity || 0);
            updateProgressMeta({ total: tasks.length, completed, hitCombos, naCombos, transientCombos, overall });
          }
        }
      );

      const tookMs = Date.now() - startedAt;

      // Remove stale sections from previous runs
      [...resultsElRef.children].forEach(sec => {
        if (sec.getAttribute && sec.getAttribute('data-run-id') !== String(runId)) {
          resultsElRef.removeChild(sec);
        }
      });

      updateProgressMeta({ total: tasks.length, completed, hitCombos, naCombos, transientCombos, overall, tookMs });
      return { overall, tookMs };
    }

    async function runDetect(force = false, { auto = false } = {}) {
      const dirSel = getDirSelection();
      const svcSel = getSvcSelection();
      const routes = await gatherRoutes();

      if (routes.length === 0) { alert('è«‹è¼¸å…¥è‡³å°‘ä¸€å€‹è·¯ç·šç·¨è™Ÿï¼ˆä¾‹å¦‚ï¼š276A æˆ– 276A,269Cï¼Œæˆ–è¼¸å…¥ ALLï¼‰'); return; }

      const key = JSON.stringify({ routesKey: usingAllRoutes ? 'ALL' : routes.join(','), mode, dirSel, svcSel, hideOk });
      if (!force && key === lastQueryKey) { /* no-op */ }
      else { safeSetParamsMulti(routes, mode, dirSel, svcSel, hideOk); }
      lastQueryKey = key;

      currentRunId++; const runId = currentRunId;

      setBusy(true, { auto });
      try {
        await detectJamMulti({ routes, dirSel, svcSel, runId });
        setFooterUpdated();
      } catch (e) {
        $('#statusArea').style.display = 'block';
        $('#statusBadge').className = 'badge bad';
        $('#statusBadge').textContent = `âŒ ${OFFLINE_TEXT}`;
        const msg = (e && e.message) ? e.message : String(e || 'æœªçŸ¥éŒ¯èª¤');
        $('#metaText').innerHTML = `<span style="color:#b31c1c;">éŒ¯èª¤ï¼š${msg}</span>`;
      } finally { setBusy(false, { auto }); }
    }

    function startAutoRefresh() {
      if (autoTimer) clearInterval(autoTimer);
      autoTimer = setInterval(() => runDetect(true, { auto: true }), 30000);
    }

    // -------- Events --------
    $('#checkBtn').addEventListener('click', () => { runDetect(); startAutoRefresh(); });
    $('#refreshBtn').addEventListener('click', () => runDetect(true));
    $('#shareBtn').addEventListener('click', async () => {
      const dirSel = getDirSelection(); const svcSel = getSvcSelection();
      const routesVal = $('#routes').value.trim().toUpperCase();
      const routes = routesVal === 'ALL' ? ['ALL'] : normalizeRoutes(routesVal);
      const tooLong = routes.join(',').length > 200 || routesVal === 'ALL';
      const url = new URL(window.location.href);
      url.searchParams.set('route', tooLong ? 'ALL' : routes.join(','));
      url.searchParams.set('mode', mode);
      url.searchParams.set('bound', dirSel);
      url.searchParams.set('serviceType', svcSel.join(','));
      url.searchParams.set('hideok', hideOk ? '1' : '0');
      const shareUrl = url.toString();
      try {
        if (navigator.share) await navigator.share({ title: 'KMB Bus Service Update', url: shareUrl });
        else if (navigator.clipboard) { await navigator.clipboard.writeText(shareUrl); alert('å·²è¤‡è£½åˆ†äº«é€£çµåˆ°å‰ªè²¼ç°¿'); }
        else { prompt('è¤‡è£½ä»¥ä¸‹é€£çµï¼š', shareUrl); }
      } catch {}
    });
    $('#allRoutesBtn').addEventListener('click', async () => {
      if (!confirm('æ­¤æ“ä½œæœƒæŠ“å–å…¨æ¸¯æ‰€æœ‰ä¹å·´è·¯ç·šä¸¦ä»¥ã€Œå…©æ–¹å‘ã€åˆ†æï¼Œå¯èƒ½éå¸¸è€—æ™‚ä¸¦æ¶ˆè€—æµé‡ã€‚æ˜¯å¦ç¹¼çºŒï¼Ÿ')) return;
      $('#routes').value = 'ALL';
      // force both directions
      [...$('#dirChips').children].forEach(c => c.classList.remove('active'));
      const bothEl = $('#dirChips').querySelector('.chip[data-value="both"]');
      if (bothEl) bothEl.classList.add('active');
      await runDetect(true);
      startAutoRefresh();
    });

    // Mode chips
    $('#modeChips').addEventListener('click', (e) => {
      const chip = e.target.closest('.chip'); if (!chip) return;
      [...$('#modeChips').children].forEach(c => c.classList.remove('active'));
      chip.classList.add('active');
      setMode(chip.dataset.value);
      setParams('mode', mode);
      updateSummaryBar();
    });

    // Direction chips
    $('#dirChips').addEventListener('click', (e) => {
      const chip = e.target.closest('.chip'); if (!chip) return;
      const val = chip.dataset.value;
      if (val === 'both') {
        [...$('#dirChips').children].forEach(c => c.classList.toggle('active', c.dataset.value === 'both'));
      } else {
        const was = chip.classList.contains('active');
        if (was && $('#dirChips').querySelectorAll('.chip.active').length === 1) return;
        chip.classList.toggle('active', !was);
        $('#dirChips .chip[data-value="both"]').classList.remove('active');
        if (!$('#dirChips').querySelectorAll('.chip.active').length) $('#dirChips .chip[data-value="outbound"]').classList.add('active');
      }
    });

    // Service chips
    $('#svcChips').addEventListener('click', (e) => {
      const chip = e.target.closest('.chip'); if (!chip) return;
      const val = chip.dataset.value;
      if (val === 'all') {
        [...$('#svcChips').children].forEach(c => c.classList.toggle('active', c.dataset.value === 'all'));
      } else {
        const was = chip.classList.contains('active');
        chip.classList.toggle('active', !was);
        $('#svcChips .chip[data-value="all"]').classList.remove('active');
        if (!$('#svcChips').querySelectorAll('.chip.active')) setActive(chip, true);
      }
    });

    // Filter chips
    $('#filterChips').addEventListener('click', (e) => {
      const chip = e.target.closest('.chip'); if (!chip) return;
      if (chip.dataset.value === 'hideok') {
        hideOk = !chip.classList.contains('active');
        chip.classList.toggle('active', hideOk);
        document.querySelectorAll('.section').forEach(sec => {
          const key = sec.getAttribute('data-key');
          const entry = comboStore.get(key);
          if (entry) applyHideRule(sec, entry.data);
        });
        setParams('hideok', hideOk ? '1' : '0');
      }
    });

    // TV floating bus: switch to mobile
    $('#busSwitch').addEventListener('click', () => {
      setMode('mobile');
      // Reflect in chips and URL
      [...$('#modeChips').children].forEach(c => c.classList.remove('active'));
      $('#modeChips .chip[data-value="mobile"]').classList.add('active');
      setParams('mode', 'mobile');
      updateSummaryBar();
    });

    // -------- Init --------
    (function init() {
      setFromParams();
      const initial = (getParam('route') || '').trim().toUpperCase();
      if (initial) {
        if (initial === 'ALL') $('#routes').value = 'ALL';
        runDetect(false);
        startAutoRefresh();
      }
    })();
  </script>
</body>
</html>
